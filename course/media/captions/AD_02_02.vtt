WEBVTT

00:00:01.776 --> 00:00:03.366
A Modern Approach

00:00:04.420 --> 00:00:09.266
There are several more modern tools
capable of enumerating AD environments.

00:00:09.658 --> 00:00:13.166
PowerShell cmdlets like Get-ADUser

00:00:13.166 --> 00:00:17.433
work well but they are only installed
by default on domain controllers

00:00:17.433 --> 00:00:23.300
and they require administrative privileges
to use when installed on workstations.

00:00:23.618 --> 00:00:27.400
We can, however, use PowerShell
to enumerate AD.

00:00:36.096 --> 00:00:39.866
We will develop a script that
will enumerate the AD users

00:00:39.866 --> 00:00:43.666
along with all the properties
of each user accounts.

00:00:43.960 --> 00:00:48.100
Although this is not as simple as
running a command like net.exe,

00:00:48.100 --> 00:00:50.900
the script will be much more flexible,

00:00:50.900 --> 00:00:54.900
allowing us to add features
and functions as needed.

00:00:55.487 --> 00:00:57.666
As we build the script, we
will discuss the various

00:00:57.666 --> 00:01:00.200
technical details about
how it works.

00:01:00.763 --> 00:01:04.081
As an overview, our script will query
the network for the name

00:01:04.081 --> 00:01:08.333
of the Primary domain controller
emulator and the domain,

00:01:08.333 --> 00:01:14.000
search Active Directory and filter
the output to display user accounts,

00:01:14.000 --> 00:01:18.000
and finally clean up the
output so it’s easier to read.

00:01:18.269 --> 00:01:21.700
This script relies on a few components.

00:01:22.189 --> 00:01:26.166
Specifically, we will use a
DirectorySearcher object,

00:01:26.166 --> 00:01:29.366
to query Active Directory using LDAP,

00:01:29.366 --> 00:01:33.633
which is a network protocol
understood by domain controllers.

00:01:34.490 --> 00:01:38.533
LDAP is essentially an API that
supports search functionality

00:01:38.533 --> 00:01:40.900
against an Active Directory.

00:01:41.365 --> 00:01:45.566
This will allow us to interface with
the domain controller using PowerShell

00:01:45.566 --> 00:01:50.866
and obtain non-privileged information
about the objects in the domain.

00:01:51.307 --> 00:01:56.033
Our script relies on a very specific
LDAP provider path

00:01:56.253 --> 00:02:00.900
which will be input to the
DirectorySearcher .NET class.

00:02:01.732 --> 00:02:05.100
To create the path, we
need the target hostname,

00:02:05.100 --> 00:02:08.566
which in this case is the name
of the domain controller,

00:02:08.566 --> 00:02:11.966
and the DistinguishedName
of the domain,

00:02:11.966 --> 00:02:17.600
which has a particular naming standard
based on specific Domain Components.

00:02:17.918 --> 00:02:21.500
First, let’s discover the hostname
of the domain controller

00:02:21.500 --> 00:02:24.166
and the components of
the DistinguishedName

00:02:24.166 --> 00:02:26.366
using a PowerShell command.

00:02:27.640 --> 00:02:31.300
Specifically, we will use the Domain class

00:02:31.300 --> 00:02:36.800
of the System.DirectoryServices.
ActiveDirectory namespace.

00:02:37.559 --> 00:02:41.966
The Domain class contains a
method called GetCurrentDomain,

00:02:41.966 --> 00:02:46.166
that will retrieve the Domain object
for the currently logged in user.

00:02:47.905 --> 00:02:52.766
According to the Name property, the
domain name is “corp.com”

00:02:53.109 --> 00:02:59.133
and the primary domain
controller is “DC01.corp.com”.

00:03:02.048 --> 00:03:04.833
We can use this information to
programmatically build

00:03:04.833 --> 00:03:06.766
the LDAP provider path.

00:03:09.975 --> 00:03:13.666
Let’s include the Name and
PdcRoleOwner properties

00:03:13.666 --> 00:03:18.300
in a simple PowerShell script
that builds the provider path.

00:03:18.569 --> 00:03:25.300
In this script, $domainObj will
store the entire domain object,

00:03:26.279 --> 00:03:30.600
$PDC will store the Name of the PDC,

00:03:30.600 --> 00:03:35.900
and $SearchString will build the
provider path for output.

00:03:37.198 --> 00:03:41.233
Notice that the DistinguishedName
will consist of our domain name,

00:03:41.233 --> 00:03:46.666
corp.com, broken down into
individual domain components.

00:03:51.860 --> 00:03:59.266
This makes the DistinguishedName
“DC=corp,DC=com”.

00:04:00.246 --> 00:04:03.833
Our current script outputs
the full LDAP provider path

00:04:03.833 --> 00:04:08.066
needed to perform LDAP queries
against the domain controller.

00:04:19.898 --> 00:04:23.000
We can now instantiate the
DirectorySearcher class

00:04:23.000 --> 00:04:25.300
with the LDAP provider path.

00:04:27.431 --> 00:04:31.633
To use the DirectorySearcher class,
we have to specify a SearchRoot,

00:04:31.633 --> 00:04:36.300
which is the node in the Active Directory
hierarchy where searches start.

00:04:36.912 --> 00:04:40.333
The search root takes the
form of an object instantiated

00:04:40.333 --> 00:04:42.566
from the DirectoryEntry class.

00:04:44.036 --> 00:04:46.400
When no arguments are
passed to the constructor,

00:04:46.400 --> 00:04:50.700
the search will return results
from the entire Active Directory.

00:04:51.875 --> 00:04:55.733
With our DirectorySearcher object
ready, we can perform a search.

00:04:56.002 --> 00:05:01.433
However, without any filters, it will
list all objects in the entire domain.

00:05:02.731 --> 00:05:07.000
One way to set up a filter is through
the samAccountType attribute,

00:05:07.000 --> 00:05:12.066
which is an attribute that all user,
computer, and group objects have.

00:05:13.169 --> 00:05:18.133
In our case, we supply a filter value to
enumerate all users in the domain.

00:05:19.039 --> 00:05:22.600
We add the samAccountType filter
through the .filter

00:05:22.600 --> 00:05:25.333
of our $Searcher object property,

00:05:26.068 --> 00:05:28.600
and then invoke the FindAll method

00:05:28.600 --> 00:05:33.133
to start a search and find
all results matching the filter.

00:05:38.547 --> 00:05:42.766
This is good information but we
should clean it up a bit.

00:05:45.877 --> 00:05:48.700
This is good information but
we should clean it up a bit.

00:05:48.944 --> 00:05:53.333
Since the attributes of an user object
are stored within the Properties field,

00:05:53.333 --> 00:05:58.766
we can add a double loop that will
print each property on its own line.

00:06:14.885 --> 00:06:17.300
The complete PowerShell
script will collect

00:06:17.300 --> 00:06:20.233
all users along with
their attributes.

00:06:28.929 --> 00:06:33.666
The output can be overwhelming since
user objects have many attributes.

00:06:43.146 --> 00:06:46.833
Using our DirectorySearcher object,
we could use a filter

00:06:46.833 --> 00:06:51.300
to locate members of specific
groups like Domain Admin,

00:06:51.300 --> 00:06:57.266
or use a filter to specifically search
only for the Jeff_Admin user.

00:06:57.928 --> 00:07:02.300
We can set any attribute of the
object type in the filter property.

00:07:02.789 --> 00:07:05.700
For example, we can
use the name property

00:07:05.700 --> 00:07:09.166
to create a filter for
the Jeff_Admin account

00:07:20.655 --> 00:07:23.300
According to the output,
the Jeff_Admin account

00:07:23.300 --> 00:07:26.000
is a member of the
Domain Admins group.

00:07:27.910 --> 00:07:33.100
Although this script may seem complicated
at first, it is extremely flexible

00:07:33.100 --> 00:07:37.966
and can be modified to perform
other AD enumeration tasks.
