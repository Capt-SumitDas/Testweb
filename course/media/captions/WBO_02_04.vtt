WEBVTT

00:00:01.200 --> 00:00:03.433
Checking for Bad Characters

00:00:04.400 --> 00:00:09.900
Depending on the application,
vulnerability type, and protocols in use,

00:00:09.900 --> 00:00:13.500
there may be certain characters that are
considered “bad”

00:00:13.500 --> 00:00:18.766
and should not be used in our buffer,
return address, or shellcode.

00:00:19.433 --> 00:00:21.833
One example of a common bad character,

00:00:21.833 --> 00:00:27.033
especially in buffer overflows caused by
unchecked string copy operations,

00:00:27.033 --> 00:00:29.166
is the null byte.

00:00:29.633 --> 00:00:33.566
This character is considered bad because a
null byte is also used

00:00:33.566 --> 00:00:35.100
to terminate a string

00:00:35.400 --> 00:00:39.166
in low level languages such as C or C++.

00:00:39.966 --> 00:00:43.600
This will cause the string copy operation
to end,

00:00:43.866 --> 00:00:48.866
effectively truncating our buffer at the
first instance of a null byte.

00:00:49.300 --> 00:00:54.333
In addition, since we are sending the
exploit as part of an HTTP POST request,

00:00:54.633 --> 00:00:56.900
we should avoid the return character,

00:00:57.233 --> 00:01:00.500
which signifies the end of an HTTP field,

00:01:00.766 --> 00:01:02.833
in this case the username.

00:01:03.933 --> 00:01:09.500
An experienced exploit developer will
always check for bad characters.

00:01:09.666 --> 00:01:13.633
One way to determine which characters are
bad for a particular exploit

00:01:13.633 --> 00:01:20.100
is to send all possible characters, from
00 to FF,

00:01:20.100 --> 00:01:25.233
as part of our buffer, and see how the
application deals with these characters

00:01:25.233 --> 00:01:26.633
after the crash.

00:01:33.733 --> 00:01:37.666
To do this, we will repurpose the proof of
concept script

00:01:37.666 --> 00:01:44.500
and replace our D’s with all possible hex
characters, except 00.

00:01:46.366 --> 00:01:50.300
We’ll run this proof of concept and
examine the crash.

00:01:58.166 --> 00:02:03.066
After executing our proof of concept, we
can right-click on ESP

00:02:03.066 --> 00:02:09.733
and select Follow in Dump to show the
input buffer hex characters in memory.

00:02:12.533 --> 00:02:18.433
The dump shows that only the hex values
01 through 09

00:02:18.433 --> 00:02:21.466
made it into the stack memory buffer.

00:02:21.733 --> 00:02:28.900
There is no sign of the next character,
0A, which should follow 09.

00:02:29.866 --> 00:02:34.933
This is not surprising when we consider
that the 0A character

00:02:34.933 --> 00:02:39.700
represents a line feed, which terminates
an HTTP field

00:02:39.700 --> 00:02:42.666
much the same way as a carriage return.

00:02:43.233 --> 00:02:48.666
We’ll quickly restart sync breeze and
immunity before we edit our script.

00:03:17.400 --> 00:03:23.233
We’ll remove 0A from our bad characters
variable and re-run the script.

00:03:39.633 --> 00:03:43.933
After removing the 0A character from our
script and resending the payload,

00:03:44.133 --> 00:03:49.566
the resulting buffer terminates after the
hex value 0C,

00:03:50.133 --> 00:03:56.800
indicating that 0D, the return character,
is also bad as we’ve already discussed.

00:03:58.333 --> 00:04:02.866
Continuing in this manner, we discover
that all  these characters will mangle

00:04:02.866 --> 00:04:07.533
our input buffer while attempting to
overflow the destination buffer.
