WEBVTT

00:00:01.566 --> 00:00:03.966
Finding a Return Address

00:00:05.133 --> 00:00:10.566
As a final step, we need to find a valid
assembly instruction to redirect code

00:00:10.566 --> 00:00:15.466
execution to the memory location pointed
to by the ESP register.

00:00:15.466 --> 00:00:18.833
The EDB debugger comes with a set of
plugins,

00:00:18.833 --> 00:00:22.300
one of which is named OpcodeSearcher.

00:00:29.333 --> 00:00:35.300
Using this plugin, we can easily search
for a JMP ESP instruction or equivalent,

00:00:35.300 --> 00:00:39.466
in the memory region where the code
section of the crossfire application

00:00:39.466 --> 00:00:40.666
is mapped.

00:00:50.700 --> 00:00:56.266
We choose to proceed using the first JMP
ESP instruction found by the debugger.

00:00:57.666 --> 00:01:02.233
We’re getting closer so let’s restart
everything before we continue.

00:01:30.166 --> 00:01:33.100
Before we work on our next proof of
concept,

00:01:33.100 --> 00:01:37.500
let’s set a breakpoint on our JMP ESP
return address.

00:01:37.700 --> 00:01:42.000
We can do this with the EDB Breakpoint
Manager plugin.

00:01:49.766 --> 00:01:56.533
We’ll click Add Breakpoint and paste in
the address of the JMP ESP instruction.

00:02:01.766 --> 00:02:06.966
With our breakpoint set, we’ll let the
application run and return to Kali.

00:02:21.133 --> 00:02:23.466
Putting the overwrite offset,

00:02:24.066 --> 00:02:25.333
return address,

00:02:26.066 --> 00:02:31.300
and first stage shellcode together,
gives us our next proof-of-concept.

00:02:31.600 --> 00:02:35.433
With the breakpoint set, we can run the
proof-of-concept.

00:02:47.666 --> 00:02:50.066
If everything has gone according to plan,

00:02:50.066 --> 00:02:54.200
our debugger should have stopped at the 
JMP ESP instruction.

00:02:57.700 --> 00:02:59.866
The breakpoint has been hit.


00:03:00.033 --> 00:03:04.700
Now we can proceed to single-step into 
the JMP ESP instruction

00:03:04.700 --> 00:03:07.933
and land at our first stage shellcode.

00:03:07.933 --> 00:03:12.166
After executing the initial first stage 
shellcode instruction

00:03:12.166 --> 00:03:17.466
we find that the EAX register now points 
to the beginning of our controlled buffer

00:03:17.466 --> 00:03:20.700
right after the “setup sound” string.

00:03:25.733 --> 00:03:30.300
Once the EAX register is aligned by our
first stage shellcode,

00:03:30.300 --> 00:03:36.133
a JMP EAX instruction brings us into a
nice, clean buffer of A’s.

00:03:36.733 --> 00:03:41.800
We’re nearly finished so let’s restart
and re-attach.
