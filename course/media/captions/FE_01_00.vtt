WEBVTT

00:00:01.179 --> 00:00:03.833
Fixing Memory Corruption Exploits

00:00:05.013 --> 00:00:07.766
Memory corruption exploits,
such as buffer overflows,

00:00:07.773 --> 00:00:11.933
are relatively complex and can be difficult to modify.

00:00:12.532 --> 00:00:14.366
Before we jump into an example,

00:00:14.366 --> 00:00:18.500
we should discuss the process
and highlight some of the considerations

00:00:18.500 --> 00:00:20.700
and challenges we will face.

00:00:21.356 --> 00:00:26.166
The general flow of a standard stack
overflow is fairly straight-forward.

00:00:26.699 --> 00:00:28.266
The exploit will:

00:00:28.266 --> 00:00:31.766
Create a large buffer to
trigger the overflow.

00:00:32.166 --> 00:00:34.633
Take control of EIP

00:00:34.633 --> 00:00:37.900
by overwriting a
return address on the stack

00:00:37.900 --> 00:00:42.133
by padding the large buffer
with an appropriate offset.

00:00:42.884 --> 00:00:48.533
Include in the buffer a chosen payload
prepended by an optional NOP sled.

00:00:49.294 --> 00:00:52.000
Choose a correct
return address instruction

00:00:52.000 --> 00:00:53.833
such as JMP ESP

00:00:53.833 --> 00:00:58.200
in order to redirect the
execution flow into our payload.

00:00:59.560 --> 00:01:04.500
As we fix the exploit, we may need to
modify elements of the deployed buffer

00:01:04.500 --> 00:01:05.900
to suit our target

00:01:05.900 --> 00:01:07.800
such as file paths,

00:01:07.800 --> 00:01:11.300
IP addresses and ports or URLs.

00:01:11.899 --> 00:01:14.533
If these modifications alter our offset,

00:01:14.533 --> 00:01:16.633
we need to adjust the buffer length

00:01:16.633 --> 00:01:21.033
to ensure we overwrite the
return address with the desired bytes.

00:01:21.604 --> 00:01:25.733
Although we could trust that the return
address used in the exploit is correct,

00:01:25.733 --> 00:01:31.133
the more responsible alternative is
to find the return address ourselves.

00:01:31.666 --> 00:01:36.933
One of the most reliable ways to do this
is to clone the target environment locally

00:01:36.933 --> 00:01:38.400
in a virtual machine

00:01:38.400 --> 00:01:41.933
and then use a debugger on the
vulnerable software

00:01:41.933 --> 00:01:45.900
to obtain the memory address
of the return address instruction.

00:01:46.623 --> 00:01:51.633
We must also consider changing the payload
contained in the original exploit code.

00:01:52.128 --> 00:01:54.666
Public exploits present an inherent danger

00:01:54.666 --> 00:01:58.433
because they often contain
hex-encoded payloads

00:01:58.737 --> 00:02:02.533
that must be reverse-engineered
to determine how they function.

00:02:03.132 --> 00:02:07.566
Because of this, we must always review
the payloads used in public exploits

00:02:07.566 --> 00:02:10.300
or better yet, insert our own.

00:02:10.975 --> 00:02:15.300
When we do this, we will include
our own IP address and port numbers

00:02:15.300 --> 00:02:18.900
and possibly exclude
certain bad characters,

00:02:18.900 --> 00:02:24.266
which we can determine on our own or
glean from the exploit comments.

00:02:24.266 --> 00:02:28.266
While generating our own payload
is advised whenever possible,

00:02:28.266 --> 00:02:31.533
there are exploits which
use custom payloads

00:02:31.533 --> 00:02:36.366
that are key for a successful
compromise of the vulnerable application.

00:02:36.956 --> 00:02:41.366
If this is the case then our only option
is to reverse engineer the payload

00:02:41.366 --> 00:02:45.466
to determine how it functions
and if it is safe to execute.

00:02:46.047 --> 00:02:49.266
This is difficult and beyond
the scope of this module,

00:02:49.766 --> 00:02:53.133
so we will instead focus on
shellcode replacement.

00:02:53.742 --> 00:02:58.366
All of these considerations must be kept
in mind as we re-purpose the exploit.
