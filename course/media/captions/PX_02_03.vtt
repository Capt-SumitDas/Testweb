WEBVTT

00:00:01.807 --> 00:00:05.800
User Account Control Bypass:
Case Study

00:00:07.749 --> 00:00:10.733
There are various ways to bypass UAC.

00:00:11.282 --> 00:00:13.435
In this example, we will
demonstrate a technique

00:00:13.435 --> 00:00:17.333
that allows an administrative
user to bypass UAC

00:00:17.333 --> 00:00:20.633
by silently elevating the
integrity level.

00:00:21.456 --> 00:00:24.133
Most of the publicly known
UAC bypass techniques

00:00:24.133 --> 00:00:27.300
target a specific operating
system version.

00:00:27.931 --> 00:00:34.300
In this case, the target is our lab client
running Windows 10 build 1709.

00:00:35.343 --> 00:00:40.833
We will use an interesting UAC bypass
based on fodhelper.exe,

00:00:41.272 --> 00:00:45.200
a Microsoft support application
that runs as high integrity

00:00:45.200 --> 00:00:49.700
and is responsible for managing language
changes in the operating system.

00:00:50.633 --> 00:00:52.833
We can leverage this to bypass UAC

00:00:52.833 --> 00:00:56.700
because of the way fodhelper interacts
with the Windows Registry.

00:00:57.303 --> 00:01:00.533
 More specifically, it interacts
with registry keys

00:01:00.533 --> 00:01:04.333
that can be modified without
administrative privileges.

00:01:05.650 --> 00:01:11.366
We will find and modify these registry
keys to run a command with high integrity.

00:01:12.190 --> 00:01:16.133
We’ll begin our analysis by
running the fodhelper.exe binary.

00:01:21.650 --> 00:01:25.400
To gather detailed information regarding
the fodhelper integrity level

00:01:25.400 --> 00:01:28.600
and the permissions
required to run this process,

00:01:28.600 --> 00:01:31.866
we will inspect its application manifest.

00:01:32.525 --> 00:01:36.474
The application manifest is an
XML file containing information

00:01:36.474 --> 00:01:41.666
that lets the operating system know how
to handle the program when it is started.

00:01:49.764 --> 00:01:54.633
We can inspect the manifest with the
sigcheck utility included in Sysinternals,

00:01:54.633 --> 00:01:58.400
passing the -a argument
for extended information

00:01:58.400 --> 00:02:01.966
and the -m argument to
dump the manifest.

00:02:05.288 --> 00:02:07.566
A quick look at the results
shows that the application

00:02:07.566 --> 00:02:10.533
is meant to be run by
administrative users

00:02:10.533 --> 00:02:14.566
so it will require the full
administrator access token.

00:02:15.527 --> 00:02:18.400
The autoelevate flag is also set to true,

00:02:18.400 --> 00:02:22.833
which allows the executable
to auto-elevate to high integrity

00:02:22.833 --> 00:02:26.600
without prompting the
administrator user for consent.

00:02:33.050 --> 00:02:36.300
We will use Process Monitor
from the Sysinternals suite

00:02:36.300 --> 00:02:40.333
to gather more information
about this tool as it executes.

00:02:40.992 --> 00:02:43.433
After starting procmon.exe,

00:02:43.762 --> 00:02:50.300
we’ll run fodhelper.exe again and we’ll
set filters to focus on the activities

00:02:50.300 --> 00:02:52.533
performed by the fodhelper process.

00:03:25.117 --> 00:03:30.300
This filter significantly reduced the
output, but for this specific vulnerability

00:03:30.300 --> 00:03:33.533
we are only interested in
how this application

00:03:33.533 --> 00:03:38.766
interacts with the registry keys that can
be modified by the current user.

00:03:39.727 --> 00:03:44.466
To narrow our results, we will add another
filter with a search for “Reg”,

00:03:44.466 --> 00:03:48.866
which Procmon uses to
mark registry operations.

00:04:04.980 --> 00:04:07.633
Once our additional filter
has been added,

00:04:21.203 --> 00:04:24.700
and we should only see results
for registry operations.

00:04:25.688 --> 00:04:29.500
These are more manageable, but we want
to further reduce the output.

00:04:29.939 --> 00:04:33.233
Specifically, we want to see if the
fodhelper application is

00:04:33.233 --> 00:04:37.733
attempting to access registry
entries that do not exist.

00:04:38.364 --> 00:04:42.266
If this is the case and the permissions
of these registry keys allow it,

00:04:42.266 --> 00:04:47.133
we may be able to add those entries
and change the actions

00:04:47.133 --> 00:04:51.666
the targeted high-integrity
process is attempting to perform.

00:04:52.682 --> 00:04:57.800
This time, we will add a “Result”
filter for “NAME NOT FOUND”,

00:04:57.800 --> 00:05:00.900
an error message that indicates
that the application

00:05:00.900 --> 00:05:05.066
is attempting to access a registry
entry that does not exist.

00:05:18.627 --> 00:05:22.966
The output reveals that
fodhelper.exe does, in fact,

00:05:22.966 --> 00:05:25.433
generate the “NAME NOT FOUND” error,

00:05:25.433 --> 00:05:30.066
an indicator of a potentially
exploitable registry entry.

00:05:30.752 --> 00:05:35.333
However, since we can’t just modify
registry entries in every hive,

00:05:35.333 --> 00:05:39.366
we need to focus on the
registry hive we can control.

00:05:40.080 --> 00:05:45.966
In this case, we will focus on the
HKEY_CURRENT_USER (HKCU) hive

00:05:45.966 --> 00:05:49.133
which the current user
has the ability to modify.

00:06:21.223 --> 00:06:23.233
This is rather interesting.

00:06:23.892 --> 00:06:30.366
fodhelper.exe attempts to query a registry
key that does not appear to exist.

00:06:31.382 --> 00:06:34.333
To understand why this is
happening and what exactly

00:06:34.333 --> 00:06:38.600
this registry key is used for, we’ll
modify our Path filter

00:06:38.600 --> 00:06:42.333
and look for any access
to entries that contain

00:06:42.345 --> 00:06:46.466
ms-settings\shell\open\command.

00:06:59.505 --> 00:07:04.666
If the process can successfully
access that key in some other hive,

00:07:04.666 --> 00:07:08.100
the results will provide
us with more clues,

00:07:08.100 --> 00:07:11.533
so we will also remove
our result filter.

00:07:22.321 --> 00:07:24.500
This is an interesting result.

00:07:25.131 --> 00:07:29.566
When fodhelper does not
find the registry key in HKCU,

00:07:29.566 --> 00:07:33.100
it immediately tries to
access the same key

00:07:33.100 --> 00:07:39.533
in the HKEY_CLASSES_ROOT hive and it is
successfull since that key exists.

00:07:50.101 --> 00:07:52.666
If we search for this key in the registry,

00:07:58.650 --> 00:08:00.800
we find a valid entry.

00:08:01.294 --> 00:08:06.100
Based on this observation, and after
searching the MSDN documentation,

00:08:21.143 --> 00:08:25.633
we can infer that fodhelper
is opening a section

00:08:25.633 --> 00:08:28.366
of the Windows Settings application

00:08:28.366 --> 00:08:32.166
through the ms-settings:
application protocol.

00:08:32.962 --> 00:08:37.200
An application protocol on Windows
defines the executable to launch

00:08:37.200 --> 00:08:40.500
when a particular URL is
used by a program.

00:08:43.601 --> 00:08:49.800
These URL-Application mappings can be
defined through Registry entries

00:08:49.800 --> 00:08:54.600
similar to the ms-setting
key we found in HKCR.

00:08:55.478 --> 00:08:59.866
In this case, the application protocol
schema for ms-settings

00:08:59.866 --> 00:09:05.933
passes the execution to a COM
object instead of to a program.

00:09:07.003 --> 00:09:10.300
This can be done by setting the
DelegateExecute key

00:09:10.300 --> 00:09:13.833
value to a specific COM class ID.

00:09:14.711 --> 00:09:18.566
This is definitely interesting
because fodhelper tries to access

00:09:18.566 --> 00:09:24.100
the ms-setting registry key
within the HKCU hive first.

00:09:27.064 --> 00:09:29.233
Previous results from Process Monitor

00:09:29.233 --> 00:09:33.966
clearly showed that this
key does not exist in HKCU,

00:09:33.966 --> 00:09:36.933
but we should have the
permissions to create it.

00:09:40.831 --> 00:09:43.866
This could allow us to
hijack the execution

00:09:43.866 --> 00:09:47.433
using a properly formatted
protocol handler.

00:09:48.092 --> 00:09:51.033
Let’s try to add this key
with the REG utility.

00:09:54.052 --> 00:09:56.066
Once we have added
the registry key,

00:09:58.509 --> 00:10:01.366
We will add our result filter again,

00:10:22.888 --> 00:10:26.033
clear all the results from
Process Monitor,

00:10:33.088 --> 00:10:35.966
restart fodhelper.exe,

00:10:41.264 --> 00:10:44.133
and monitor the process activity.

00:10:47.729 --> 00:10:53.266
This time, fodhelper.exe
attempts to query a value

00:10:53.266 --> 00:10:59.566
called DelegateExecute stored in
our newly-created command key.

00:11:00.637 --> 00:11:04.933
This did not happen before we created our
fake application protocol key.

00:11:05.372 --> 00:11:10.366
However, since we do not want to hijack
the execution through a COM object,

00:11:10.723 --> 00:11:14.166
we’ll add an empty DelegateExecute entry.

00:11:15.072 --> 00:11:19.366
The plan is that when fodhelper
discovers this empty value,

00:11:19.366 --> 00:11:22.333
it will look for a program to launch

00:11:22.333 --> 00:11:27.833
specified in the
Shell\Open\command\Default key entry.

00:11:34.943 --> 00:11:37.233
We will use REG ADD,

00:11:37.370 --> 00:11:41.600
with the /v argument to
specify the value name,

00:11:42.094 --> 00:11:45.933
and /t to specify the type.

00:11:48.101 --> 00:11:51.262
In order to verify that fodhelper
successfully accesses

00:11:51.262 --> 00:11:54.233
the DelegateExecute entry
we have just added,

00:12:03.429 --> 00:12:06.233
we will remove the
“NAME NOT FOUND” filter,

00:12:11.613 --> 00:12:16.300
replace it with “SUCCESS” to show
only successful operations,

00:12:25.523 --> 00:12:28.466
and restart the process again.

00:12:44.470 --> 00:12:49.933
As expected, fodhelper finds the
new DelegateExecute entry we added,

00:12:50.345 --> 00:12:52.600
but since its value is empty,

00:12:53.945 --> 00:12:57.300
it also looks for the
(Default) entry value

00:12:57.300 --> 00:13:00.966
of the Shell\open\command
registry key.

00:13:02.009 --> 00:13:07.966
The (Default) entry value is automatically
set to null when adding any registry key.

00:13:12.468 --> 00:13:19.833
We will replace the empty (Default) value
with an executable of our choice, cmd.exe.

00:13:20.574 --> 00:13:24.766
This should force fodhelper to
handle the ms-settings: protocol

00:13:24.766 --> 00:13:27.100
with our own executable!

00:13:28.664 --> 00:13:35.466
To test this theory, we’ll specify the
new registry value with /d “cmd.exe”,

00:13:36.043 --> 00:13:40.266
and use /f to add the value silently.

00:13:42.133 --> 00:13:46.433
After setting the value and running
fodhelper.exe once again,

00:13:47.201 --> 00:13:49.366
we are presented with a command shell.

00:13:54.994 --> 00:13:58.200
The output of the
whoami /groups command

00:13:58.200 --> 00:14:02.033
shows that this is a
high-integrity command shell.

00:14:02.829 --> 00:14:06.100
Let’s attempt to change
the admin password,

00:14:07.390 --> 00:14:11.133
Excellent. The password
change is successful

00:14:11.133 --> 00:14:14.466
and we have successfully bypassed UAC!

00:14:15.372 --> 00:14:19.000
This attack not only demonstrates
a terrific UAC bypass,

00:14:19.000 --> 00:14:24.933
but also reveals a process that we
could use to discover similar bypasses.
