WEBVTT

00:00:01.266 --> 00:00:02.866
Getting a Shell

00:00:03.833 --> 00:00:07.466
All that’s left to do now is drop our
payload at the beginning of our

00:00:07.466 --> 00:00:11.400
buffer of A’s reachable through the first 
stage shellcode.

00:00:11.666 --> 00:00:16.966
We’ll use a reverse shell as our payload
and generate it using msfvenom.

00:00:19.966 --> 00:00:23.466
We’ll pass -p to specify the payload,

00:00:23.466 --> 00:00:27.433
followed by values for LHOST and LPORT.

00:00:27.966 --> 00:00:33.300
We also specify the bad characters to 
avoid with the -b flag,

00:00:33.766 --> 00:00:36.866
the output format with -f,

00:00:37.466 --> 00:00:41.066
and the variable name to use with -v.

00:00:46.166 --> 00:00:50.833
Let’s take a look at how this payload
is added to our final proof of concept.

00:00:57.266 --> 00:01:00.800
Our payload is placed towards the 
beginning of our buffer,

00:01:00.800 --> 00:01:04.733
which means that we need to take the
payload size into account

00:01:04.733 --> 00:01:08.200
and pad it with the correct amount of “A”
characters.

00:01:09.333 --> 00:01:14.033
This will ensure that we maintain the
original offset in order to overwrite the

00:01:14.033 --> 00:01:16.700
EIP register with our desired bytes.

00:01:23.566 --> 00:01:28.600
Before we launch our final exploit, let’s
open up a new terminal and setup a netcat

00:01:28.600 --> 00:01:30.333
listener to catch our shell.

00:01:45.166 --> 00:01:47.466
Now let’s send our exploit.

00:01:52.700 --> 00:01:55.966
We’ve received a connection on our Netcat
listener,

00:02:00.433 --> 00:02:03.566
However, the shell appears to be stuck.

00:02:06.300 --> 00:02:11.200
Going back to our debugger window, it 
appears that the application is paused.

00:02:13.833 --> 00:02:18.933
When we attempt to let it run, we receive
a message regarding a debug event.

00:02:18.933 --> 00:02:24.400
Clicking OK on the event and going back
to our Netcat listener solves the problem.

00:02:27.600 --> 00:02:32.933
However, every time we run the exploit,
we would have to repeat this process.


00:02:36.733 --> 00:02:40.900
This is because the debugger is catching
SIGCHLD events

00:02:40.900 --> 00:02:45.966
when the child process spawned by our
reverse shell generates a signal,

00:02:45.966 --> 00:02:51.600
for example when the process exits,
crashes, stops, etc.

00:02:56.200 --> 00:02:59.066
To ensure that our exploit is working as 
intended,

00:02:59.066 --> 00:03:04.800
we’ll restart the Crossfire application 
and run it without a debugger attached.

00:03:10.966 --> 00:03:13.466
Now let’s try running our exploit again.

00:03:29.400 --> 00:03:33.733
As we suspected, running the application 
without a debugger attached

00:03:33.733 --> 00:03:37.700
provides us with a working reverse shell 
from the victim machine.
