WEBVTT

00:00:01.300 --> 00:00:04.233
Locating Space for Your Shellcode

00:00:05.300 --> 00:00:09.366
Next, we must find if there are any
registers that point to our buffer

00:00:09.366 --> 00:00:10.933
at the time of the crash.

00:00:11.300 --> 00:00:16.500
This step is essential, allowing us to
subsequently attempt to identify possible

00:00:16.500 --> 00:00:23.033
JMP or CALL instructions that can
redirect the execution flow to our buffer.

00:00:23.866 --> 00:00:29.200
We notice that the ESP register points to
the end of our buffer, leaving only seven

00:00:29.200 --> 00:00:31.733
bytes of space for shellcode.

00:00:32.133 --> 00:00:36.033
Furthermore, after a bit of
experimentation, we determined that we

00:00:36.033 --> 00:00:41.466
can’t increase the overflow buffer size
in an attempt to gain more space.

00:00:41.466 --> 00:00:46.933
Even a single byte increase produces a
different crash that does not properly

00:00:46.933 --> 00:00:48.666
overwrite EIP.

00:00:48.833 --> 00:00:52.200
Taking a closer look at the state of our
registers at crash time

00:00:52.200 --> 00:00:54.166
reveals more options.

00:00:56.233 --> 00:01:00.400
The EAX register seems to point to the
beginning of our buffer,

00:01:00.900 --> 00:01:03.833
including the “setup sound” string.

00:01:05.633 --> 00:01:09.900
The fact that EAX points directly to the
beginning of the command string

00:01:09.900 --> 00:01:14.800
may impact our ability to simply jump to
the buffer pointed at by EAX,

00:01:15.033 --> 00:01:20.300
as we would be executing the hex opcodes
equivalent of the ASCII string

00:01:20.300 --> 00:01:23.566
“setup sound” before our shellcode.

00:01:23.800 --> 00:01:27.000
This would most likely mangle the
execution path

00:01:27.000 --> 00:01:29.300
and cause our exploit to fail.

00:01:33.200 --> 00:01:35.166
Or would it?

00:01:46.233 --> 00:01:50.900
Further examination of the actual opcodes
generated by the “setup sound” string

00:01:50.900 --> 00:01:53.833
reveals some interesting instructions.

00:01:53.833 --> 00:01:57.900
It seems that the opcode instructions
for the first two letters of the word

00:01:57.900 --> 00:02:05.333
“setup”, s and e, translate to a
conditional jump instruction, which seems


00:02:05.333 --> 00:02:08.700
to jump to a nearby location in our
controlled buffer.

00:02:08.700 --> 00:02:14.900
The next two letters, t and u, translate
to a slightly different conditional jump.

00:02:14.900 --> 00:02:20.533
All these jumps seem to be leading into
our controlled buffer so a jump to EAX


00:02:20.533 --> 00:02:22.666
might actually work for us in this case.

00:02:23.533 --> 00:02:28.466
However, this is not an elegant solution
so let’s Try Harder.

00:02:29.533 --> 00:02:34.466
Continuing our analysis, it looks like
the ESP register points toward the end

00:02:34.466 --> 00:02:39.366
of our unique buffer at the time of the
crash but this only gives us a few bytes

00:02:39.366 --> 00:02:41.200
of shellcode to work with.

00:02:49.800 --> 00:02:54.300
We can try to insert a first stage
shellcode into that limited space.

00:02:54.666 --> 00:02:57.966
Rather than an actual payload such as a
reverse shell,

00:02:57.966 --> 00:03:03.133
this first stage shellcode will be used
to align the EAX register

00:03:03.133 --> 00:03:08.000
register in order to make it point to our
buffer right after the “setup sound”

00:03:08.000 --> 00:03:14.600
string and then jump to that location,
allowing us to skip the conditional jumps.

00:03:37.900 --> 00:03:42.300
In order to achieve this, our first stage
shellcode would need to increase the

00:03:42.300 --> 00:03:49.666
value of EAX by 12 bytes as there are 12
characters in the string “setup sound”.

00:03:55.733 --> 00:04:00.333
We can accomplish this with an ADD
assembly instruction and then proceed

00:04:00.333 --> 00:04:05.966
to jump to the memory pointed to by EAX
using a JMP instruction.

00:04:07.866 --> 00:04:12.066
In order to get the correct opcodes for
our instructions, we use the

00:04:12.066 --> 00:04:15.866
msf-nasm_shell utility from Metasploit.

00:04:20.366 --> 00:04:23.833
Fortunately for us, these two sets of
instructions take up

00:04:23.833 --> 00:04:26.033
only 5 bytes of memory.

00:04:35.266 --> 00:04:40.333
We can update the proof-of-concept by
including the first stage shellcode and

00:04:40.333 --> 00:04:45.833
repadding the original buffer with NOPs
in order to maintain the correct length.

00:04:46.266 --> 00:04:49.500
Let’s give this new proof of concept a
try.

00:05:01.333 --> 00:05:05.500
Our updated proof-of-concept code is
working perfectly.

00:05:05.700 --> 00:05:09.433
The EIP register is overwritten with four
B’s,

00:05:16.500 --> 00:05:20.866
and our first stage shellcode is located
at the memory address pointed to

00:05:20.866 --> 00:05:22.866
by the ESP register.
