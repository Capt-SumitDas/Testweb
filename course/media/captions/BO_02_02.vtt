WEBVTT

00:00:01.745 --> 00:00:04.279
Introducing the Immunity Debugger

00:00:05.631 --> 00:00:08.731
We can use an application
called a debugger

00:00:08.731 --> 00:00:11.743
to assist with the exploit
development process.

00:00:12.191 --> 00:00:16.724
A debugger acts as a proxy between
the application and the CPU,

00:00:16.724 --> 00:00:21.391
and it allows us to stop the
execution flow at any time

00:00:21.391 --> 00:00:26.557
to inspect the content of the registers as
well as the process memory space.

00:00:30.955 --> 00:00:33.388
While running an application
through a debugger,

00:00:33.388 --> 00:00:37.521
we can also execute assembly
instructions one at a time

00:00:37.543 --> 00:00:41.076
to better understand the detailed
flow of the code.

00:00:45.455 --> 00:00:49.621
Although there are many debuggers
available, we’ll use Immunity Debugger,

00:00:49.621 --> 00:00:53.221
which has a relatively simple
interface and allows us to use

00:00:53.243 --> 00:00:56.243
Python scripts to automate tasks.

00:00:59.236 --> 00:01:03.303
We can attempt to overflow the buffer in
our vulnerable test application

00:01:03.324 --> 00:01:08.824
and use Immunity Debugger to
better understand what exactly happens

00:01:08.845 --> 00:01:11.512
at each stage of the program execution.

00:01:12.452 --> 00:01:16.885
To execute the vulnerable program,
we’ll open it via the File menu.

00:01:21.776 --> 00:01:25.909
In the dialog, we select strcpy.exe,

00:01:25.909 --> 00:01:30.176
which is the compiled version of
the source code we analyzed earlier.

00:01:31.964 --> 00:01:37.397
Prior to clicking Open, we’ll add twelve
“A” characters to the Arguments field.

00:01:39.197 --> 00:01:43.897
These 12 characters will serve as the
command-line argument to the program

00:01:43.897 --> 00:01:47.731
and will subsequently be used
by the string copy function.

00:01:50.676 --> 00:01:53.009
When the debugger launches
the application,

00:01:53.009 --> 00:01:57.709
the execution flow of the program
will be paused at the entry point.

00:01:58.621 --> 00:02:00.555
Unfortunately, in this example,

00:02:00.555 --> 00:02:04.988
the entry point does not coincide
with the beginning of the main function.

00:02:05.876 --> 00:02:10.543
This is not uncommon as often the
entry point is set by the compiler

00:02:10.543 --> 00:02:15.643
to a section of code created to help
prepare the execution of the program.

00:02:16.221 --> 00:02:19.455
Among other things, this preparation
includes setting up

00:02:19.455 --> 00:02:22.655
all the arguments that main may expect.

00:02:23.321 --> 00:02:26.755
Before going further, let’s become
more familiar with Immunity

00:02:26.766 --> 00:02:30.310
and practice navigating the
most relevant features.

00:02:30.310 --> 00:02:34.242
The main screen is split into
four windows or panes.

00:02:36.376 --> 00:02:41.143
The upper left window shows the assembly
instructions that make up the application

00:02:41.824 --> 00:02:46.557
The instruction highlighted
in blue, SUB ESP, 0C

00:02:46.557 --> 00:02:51.457
is the assembly instruction to be
executed next and its location in the

00:02:51.521 --> 00:02:55.521
process memory space is displayed
in the left-most column.

00:02:57.221 --> 00:02:59.788
The upper right window
contains all the registers,

00:02:59.788 --> 00:03:05.055
including the two we are most
interested in: ESP and EIP.

00:03:06.109 --> 00:03:11.443
Since, by definition, EIP points to the
next code instruction to be executed,

00:03:11.464 --> 00:03:16.597
it's set to the address of the instruction
highlighted in the assembly window.

00:03:19.755 --> 00:03:23.588
The lower right window show
the stack and its content.

00:03:24.555 --> 00:03:26.855
This view contains four columns:

00:03:27.355 --> 00:03:28.655
a memory address,

00:03:29.379 --> 00:03:32.012
the hex data residing
at that address,

00:03:32.712 --> 00:03:35.145
an ASCII representation of the data,

00:03:35.964 --> 00:03:40.131
and a dynamic commentary that
provides additional information

00:03:40.131 --> 00:03:43.697
related to a particular
stack entry when available.

00:03:44.921 --> 00:03:50.855
The data itself (in the second column)
is displayed as a 32-bit value,

00:03:50.876 --> 00:03:55.909
called a DWORD, displayed
as four hexadecimal bytes.

00:03:56.555 --> 00:03:58.806
Note that the address at
the top of this pane

00:03:58.806 --> 00:04:03.700
is identical to the value stored
in ESP in the register window.

00:04:04.579 --> 00:04:06.645
The final window, in the lower left,

00:04:06.667 --> 00:04:10.500
shows the contents of
memory at any given address.

00:04:12.009 --> 00:04:13.576
Similar to the stack window,

00:04:13.576 --> 00:04:17.009
it shows three columns
including the memory address

00:04:17.009 --> 00:04:21.109
and the hex and ASCII
representations of the data.

00:04:21.521 --> 00:04:23.055
As the name suggests,

00:04:23.055 --> 00:04:27.221
this window can be helpful while
searching for or analyzing specific

00:04:27.221 --> 00:04:29.955
values in the process memory space

00:04:30.245 --> 00:04:36.445
and it can show data in different formats
by right-clicking on the window content

00:04:36.467 --> 00:04:39.133
to access the contextual menu:
