WEBVTT

00:00:01.806 --> 00:00:05.600
Troubleshooting the
“index out of range” Error

00:00:13.838 --> 00:00:17.066
Inspecting line 24 of our exploit,

00:00:17.499 --> 00:00:20.233
we notice that it uses the split method

00:00:20.233 --> 00:00:22.233
in order to slice the string

00:00:22.233 --> 00:00:24.233
stored in the location parameter

00:00:24.233 --> 00:00:28.533
passed to the parse_csrf_token function.

00:00:32.603 --> 00:00:35.066
The Python documentation for split

00:00:35.066 --> 00:00:39.066
 indicates that this method
slices the input string

00:00:39.066 --> 00:00:41.500
using an optional separator

00:00:41.500 --> 00:00:43.533
passed as a first argument.

00:00:45.747 --> 00:00:48.466
The string slices returned by split

00:00:48.466 --> 00:00:52.000
are then stored in a Python List object

00:00:53.484 --> 00:00:56.333
that can be accessed via an index

00:01:02.308 --> 00:01:03.533
In our exploit code,

00:01:03.533 --> 00:01:09.900
the string separator is defined
as the csrf_param variable

00:01:09.900 --> 00:01:12.433
followed by the equals sign:

00:01:14.066 --> 00:01:16.866
In order to better understand
the IndexError,

00:01:16.866 --> 00:01:22.200
we can add a print statement in the
parse_csrf_token function

00:01:22.200 --> 00:01:24.933
before the return instruction

00:01:29.386 --> 00:01:34.800
The exploit now displays the full string
before the split method is invoked:

00:01:41.145 --> 00:01:47.465
The exploit code expected the
input string to contain “c”,

00:01:47.465 --> 00:01:51.300
defined in the csrf_param variable

00:01:55.023 --> 00:02:00.933
But we received _sk_
from the web application.

00:02:02.174 --> 00:02:06.300
At this point we do not fully understand
why this is happening.

00:02:06.300 --> 00:02:08.433
Perhaps there is a version mismatch

00:02:08.433 --> 00:02:11.733
between the exploit developer’s software and ours,

00:02:11.733 --> 00:02:15.233
or a CMS configuration mismatch.

00:02:15.579 --> 00:02:16.233
Either way,

00:02:16.233 --> 00:02:19.333
exploit development is
never straight-forward.

00:02:20.465 --> 00:02:24.933
Nevertheless, we can try to change
the csrf_param variable

00:02:24.933 --> 00:02:33.066
from __c to _sk_ in order
to match the CMS response

00:02:41.466 --> 00:02:44.466
Now, let’s execute the modified exploit:

00:02:57.801 --> 00:02:59.733
The error is no longer displayed

00:02:59.733 --> 00:03:04.766
and we are presented with a message
informing us that the exploit has succeeded.

00:03:06.869 --> 00:03:09.900
Although we don’t clearly understand
why we needed to change

00:03:09.900 --> 00:03:13.800
the csrf_param variable from “c” to “sk”,

00:03:13.800 --> 00:03:19.300
this presented a great opportunity to
adapt to unexpected situations,

00:03:19.300 --> 00:03:23.266
something great penetration
testers do very well.

00:03:24.194 --> 00:03:28.900
Now, we can validate the exploit
by attaching to the php shell

00:03:28.900 --> 00:03:34.733
 with a tool like curl and supplying a
system command to serve as the payload:

00:03:38.435 --> 00:03:39.266
Nice.

00:03:39.266 --> 00:03:43.500
The exploit was successful.
We have a web shell.
