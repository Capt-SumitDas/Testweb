WEBVTT

00:00:01.330 --> 00:00:03.163
CPU Registers

00:00:04.307 --> 00:00:06.941
To perform efficient code execution,

00:00:06.941 --> 00:00:12.674
the CPU maintains and uses a series
of nine 32-bit registers.

00:00:14.141 --> 00:00:19.607
Registers are small, extremely
high-speed CPU storage locations

00:00:19.607 --> 00:00:23.341
where data can be efficiently
read or manipulated.

00:00:23.785 --> 00:00:27.752
The register names were established
for 16-bit architectures

00:00:27.752 --> 00:00:32.052
and were then extended with
the advent of the 32-bit platform,

00:00:32.052 --> 00:00:35.652
hence the letter “E” in the
register’s acronym.

00:00:37.452 --> 00:00:45.219
Each register may contain a 32-bit value
or may contain 16-bit or 8-bit values 

00:00:45.219 --> 00:00:51.552
in the respective subregisters as shown
in this example for the EAX register.

00:00:52.419 --> 00:00:56.419
Since the purpose of this module
is to demonstrate a buffer overflow,

00:00:56.419 --> 00:01:00.519
we will not delve into the details
of assembly, but will highlight 

00:01:00.530 --> 00:01:04.596
some of the elements that are
important to our specific discussion.

00:01:06.696 --> 00:01:10.730
For more detail, or to advance beyond 
the basic techniques discussed here,

00:01:10.741 --> 00:01:14.307
refer to the online resources
in your lab guide

00:01:16.274 --> 00:01:18.474
General Purpose Registers

00:01:19.796 --> 00:01:24.330
Several registers are often used
as general purpose registers

00:01:24.330 --> 00:01:26.363
to store temporary data.

00:01:26.907 --> 00:01:28.696
There is much more to this discussion,

00:01:28.696 --> 00:01:32.130
but the primary registers
for our purposes are:

00:01:32.574 --> 00:01:40.074
EAX, which is the accumulator and is used
for arithmetical and logical instructions,

00:01:40.741 --> 00:01:45.007
EBX, the base pointer for
memory addresses,

00:01:45.452 --> 00:01:52.318
ECX, the count register, which is used as
a loop, shift, and rotation counter,

00:01:52.874 --> 00:01:58.641
EDX, used for I/O port addressing,
multiplication, and division,

00:01:59.385 --> 00:02:01.952
ESI, the source index

00:02:01.952 --> 00:02:07.252
used as a pointer addressing the
data source in string copy operations,

00:02:07.863 --> 00:02:12.063
and EDI, which is the destination index

00:02:12.063 --> 00:02:15.930
used as a pointer addressing the
desination memory buffer

00:02:15.941 --> 00:02:17.974
in string copy operations.

00:02:21.318 --> 00:02:25.985
ESP, EBP, and EIP

00:02:27.230 --> 00:02:30.830
As we’ve mentioned, the stack
is used for storage of data,

00:02:30.830 --> 00:02:32.796
pointers, and arguments.

00:02:33.296 --> 00:02:37.763
Since the stack is dynamic and changes
constantly during program execution,

00:02:37.763 --> 00:02:43.596
ESP, the stack pointer, keeps track of
the most recently referenced location

00:02:43.596 --> 00:02:46.930
on the stack by storing
a pointer to it.

00:02:48.030 --> 00:02:52.463
A pointer is a reference to an
address, or location, in memory.

00:02:53.141 --> 00:02:56.907
When we say a register stores a
pointer or points to an address,

00:02:56.907 --> 00:03:01.741
this essentially means that the
register is storing that target address.

00:03:02.185 --> 00:03:06.119
Since the stack is in constant flux
during the execution of a thread,

00:03:06.130 --> 00:03:10.396
it can become difficult for a function
to locate its own stack frame,

00:03:10.396 --> 00:03:15.730
which stores the required arguments,
local variables, and the return address.

00:03:16.230 --> 00:03:18.163
EBP, the base pointer,

00:03:18.163 --> 00:03:22.996
solves this by storing a pointer to the
top of the stack when a function is called

00:03:23.718 --> 00:03:25.352
By accessing EBP,

00:03:25.352 --> 00:03:29.952
a function can easily reference
information from its own stack frame,

00:03:29.952 --> 00:03:32.685
via offsets, while executing.

00:03:33.830 --> 00:03:35.930
EIP, the instruction pointer,

00:03:35.930 --> 00:03:39.296
is one of the most important
registers for our purposes

00:03:39.296 --> 00:03:43.963
as it always points to the
next code instruction to be executed.

00:03:44.852 --> 00:03:48.352
Since EIP essentially directs
the flow of a program,

00:03:48.352 --> 00:03:50.885
it is an attacker’s primary target

00:03:50.885 --> 00:03:55.919
when exploiting any memory corruption
vulnerability such as a buffer overflow.
