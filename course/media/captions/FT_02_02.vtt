WEBVTT

00:00:01.565 --> 00:00:06.133
Windows Downloads Using Scripting 
Languages

00:00:06.133 --> 00:00:10.700
 We can leverage scripting engines such as 
VBScript and PowerShell 

00:00:10.700 --> 00:00:13.900
to download files on our victim machine.

00:00:17.500 --> 00:00:22.500
For example, the following set of 
non-interactive echo commands, 

00:00:22.500 --> 00:00:24.733
when pasted into a remote shell, 

00:00:24.733 --> 00:00:31.868
will write out a wget.vbs script that 
acts as a simple HTTP downloader:

00:00:32.325 --> 00:00:36.679
Let’s select all of this and copy it to 
our clipboard.

00:00:37.933 --> 00:00:42.466
We’ll also copy the Windows version 
of wget to our webroot 

00:00:42.466 --> 00:00:44.433
so we have something to download.

00:00:47.861 --> 00:00:55.300
Now we’ll paste our echo commands into 
the Windows bind shell to create wget.vbs.

00:00:56.939 --> 00:01:02.300
Now we can run our wget.vbs file 
with cscript 

00:01:02.300 --> 00:01:05.600
to download files from our Kali machine:

00:01:05.600 --> 00:01:11.933
The script requires a source URI and the 
local filename for the download.

00:01:18.864 --> 00:01:23.898
Great, our file was downloaded correctly.

00:01:23.898 --> 00:01:27.866
For more recent versions of Windows, 
we can use PowerShell

00:01:27.866 --> 00:01:31.400
as an even simpler download alternative.

00:01:32.667 --> 00:01:37.300
This example shows an implementation 
of a downloader script

00:01:37.300 --> 00:01:42.833
using the System.Net.WebClient 
PowerShell class.

00:01:42.833 --> 00:01:48.633
Let’s copy this to the clipboard and 
paste it into our bind shell terminal.

00:01:51.933 --> 00:01:57.766
Now we can use PowerShell to run 
the script and download our file.

00:01:57.766 --> 00:02:01.833
However, to ensure both correct 
and stealthy execution, 

00:02:01.833 --> 00:02:06.698
we specify a number of options 
in the execution of the script.

00:02:06.698 --> 00:02:10.300
First, we must allow execution of 
PowerShell scripts 

00:02:10.300 --> 00:02:13.666
with the -ExecutionPolicy keyword.

00:02:13.666 --> 00:02:17.333
Next, we will use NoLogo and 
NonInteractive 

00:02:17.333 --> 00:02:19.733
to hide the PowerShell logo banner 

00:02:19.733 --> 00:02:24.733
and suppress the interactive PowerShell 
prompt, respectively.

00:02:24.733 --> 00:02:28.266
The NoProfile keyword will prevent 
PowerShell

00:02:28.266 --> 00:02:31.933
from loading the default profile (which 
is not needed), 

00:02:31.933 --> 00:02:35.866
and finally we specify the script 
with File.

00:02:39.133 --> 00:02:42.366
Rather than creating a script, we can 
execute all of the commands 

00:02:42.366 --> 00:02:44.200
as a one-liner.

00:02:49.633 --> 00:02:52.966
If we want to download and execute a 
PowerShell script 

00:02:52.966 --> 00:02:54.533
without saving it to disk, 

00:02:54.533 --> 00:02:59.500
we can once again use the 
System.Net.Webclient class.

00:03:03.077 --> 00:03:06.566
This is done by combining the 
DownloadString method 

00:03:06.566 --> 00:03:10.010
with the Invoke-Expression cmdlet.

00:03:10.010 --> 00:03:14.600
To demonstrate this, we’ll use a simple 
powershell script on our Kali machine.

00:03:16.666 --> 00:03:20.666
Next, we’ll run the script on our 
compromised Windows machine.

00:03:24.393 --> 00:03:29.166
The content of the PowerShell script was 
downloaded from our Kali machine 

00:03:29.166 --> 00:03:33.966
and successfully executed without 
saving it to the target’s hard disk.
