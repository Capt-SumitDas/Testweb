WEBVTT

00:00:01.360 --> 00:00:03.066
Changing the Payload

00:00:04.311 --> 00:00:07.066
Continuing the analysis of our C exploit,

00:00:07.066 --> 00:00:09.700
we notice that the shellcode variable

00:00:09.700 --> 00:00:11.800
seems to hold the payload.

00:00:13.096 --> 00:00:15.000
Since it is stored as hex bytes,

00:00:15.000 --> 00:00:17.866
we can not easily determine its purpose.

00:00:18.443 --> 00:00:20.600
The only hint given by the author

00:00:20.600 --> 00:00:24.766
refers to a NOP slide that is
part of the shellcode variable:

00:00:26.295 --> 00:00:28.500
Since we have already determined
the bad characters

00:00:28.500 --> 00:00:30.833
from our research in the previous exploit,

00:00:30.833 --> 00:00:35.133
we can generate our own
payload with msfvenom:

00:00:47.828 --> 00:00:52.400
We’ll copy this shellcode to the
clipboard and replace it in our exploit.

00:01:19.600 --> 00:01:24.000
Let’s compile the exploit code
using mingw-64

00:01:24.000 --> 00:01:26.700
to see if it generates any errors:

00:01:39.833 --> 00:01:41.466
Now that we have an updated,

00:01:41.466 --> 00:01:43.633
clean-compiling exploit,

00:01:43.633 --> 00:01:44.966
we can test it out.

00:01:51.794 --> 00:01:53.466
With our debugger still attached to the

00:01:53.466 --> 00:01:56.666
SyncBreeze service on our
sandboxed test target

00:02:04.031 --> 00:02:08.900
we set a breakpoint at the
memory address of our JMP ESP instruction,

00:02:09.708 --> 00:02:12.400
Once our breakpoint has been
set in the debugger,

00:02:12.400 --> 00:02:14.633
we can let the application run normally

00:02:14.633 --> 00:02:18.100
and attempt to execute our
exploit from Kali Linux.

00:02:28.121 --> 00:02:30.100
Before we try running our exploit,

00:02:30.100 --> 00:02:33.300
we’ll set up a netcat listener
to catch the shell.

00:02:47.400 --> 00:02:51.300
Because this binary is cross-compiled
to run on Windows,

00:02:51.300 --> 00:02:55.033
we can’t simply run it from our
Kali Linux machine.

00:02:58.235 --> 00:03:02.466
In order to run this Windows binary,
we will use wine

00:03:07.045 --> 00:03:09.382
The exploit appears to have run correctly

00:03:09.382 --> 00:03:12.600
but we haven’t received
a shell on our listener.

00:03:19.892 --> 00:03:23.600
Surprisingly, we do not hit
our breakpoint at all.

00:03:24.824 --> 00:03:27.366
Instead, the application crashed

00:03:27.366 --> 00:03:37.033
and the EIP register seems to be
overwritten by 9010090c.

00:03:47.439 --> 00:03:51.066
By analyzing both the value stored in EIP

00:03:51.066 --> 00:03:53.933
and the buffer sent
to the target application, 

00:03:53.933 --> 00:03:58.633
we notice that our offset to overwrite
the return address on the stack

00:03:58.633 --> 00:04:01.266
seems to be one byte off.

00:04:02.915 --> 00:04:08.333
The wrong offset forces the execution
flow to be redirected to a different

00:04:08.333 --> 00:04:12.100
memory address than that
of our return address.

00:04:15.670 --> 00:04:20.033
Let’s restart Sync Breeze before
we continue with our investigation.

00:04:25.092 --> 00:04:28.433
We can do this via the
service managment console.

00:04:48.605 --> 00:04:52.300
Now let’s return to Kali and
see if we can fix our exploit.
