WEBVTT

00:00:01.426 --> 00:00:02.666
Enumeration

00:00:03.759 --> 00:00:06.533
At this point in the enumeration
step of the database,

00:00:06.533 --> 00:00:09.166
we already know a couple of things.

00:00:09.743 --> 00:00:12.333
Because of access to the
WordPress server,

00:00:12.333 --> 00:00:16.166
we know that the host is
not in our current network.

00:00:16.773 --> 00:00:22.233
We also know that the database
is running MariaDB 10.3.20,

00:00:22.233 --> 00:00:26.675
which is a fairly recent version,
so it most likely won’t

00:00:26.675 --> 00:00:31.366
have vulnerabilities discovered
that lead to remote code execution.

00:00:31.882 --> 00:00:37.266
Let’s connect to the database and start
enumerating other aspects of MariaDB.

00:00:39.269 --> 00:00:42.433
Application/Service Enumeration

00:00:43.404 --> 00:00:48.966
To connect to MariaDB, we can
use Kali’s built in MySQL client

00:00:49.300 --> 00:00:54.000
along with the credentials we recovered
from the WordPress configuration file.

00:00:55.790 --> 00:00:58.608
We will also need to
point the MySQL client

00:00:58.608 --> 00:01:03.800
to the tunnel running
on Kali on port 13306.

00:01:06.713 --> 00:01:11.833
Now that we are connected, we can look at
what privileges we have as the wp user

00:01:11.833 --> 00:01:16.400
to get a better idea of how this
MariaDB instance is configured.

00:01:18.099 --> 00:01:20.766
We don’t have "*" permissions,

00:01:20.766 --> 00:01:26.433
but SELECT, INSERT, UPDATE, and
DELETE are a good starting point.

00:01:27.252 --> 00:01:29.711
Next, let’s take a look at some variables

00:01:29.711 --> 00:01:32.966
and see if we can find
anything that stands out.

00:01:35.303 --> 00:01:38.833
The hostname of this server is “zora”,

00:01:38.833 --> 00:01:42.466
which is how we’ll refer
to it from this point on.

00:01:42.952 --> 00:01:47.233
We also learned that the
temp directory is in /var/tmp.

00:01:48.720 --> 00:01:53.733
We confirmed that we are
running MariaDB version 10.3.20,

00:01:54.461 --> 00:02:00.266
but we now know that the
target architecture is x86_64.

00:02:00.934 --> 00:02:03.881
The most interesting piece of
information we can gather

00:02:03.881 --> 00:02:07.200
is the location of
the plugin directory.

00:02:07.897 --> 00:02:11.066
This directory is not standard for MariaDB

00:02:11.066 --> 00:02:16.133
so we’ll take note of that as
it might become useful later on.

00:02:20.017 --> 00:02:21.811
Now that we have gathered
some information,

00:02:21.811 --> 00:02:26.733
let’s see if we can find any exploits
for our target MariaDB version.

00:02:29.373 --> 00:02:34.200
Unfortunately, none of these would
work for our version of MariaDB.

00:02:35.929 --> 00:02:40.200
Let’s broaden the scope and
see what we get for MySQL.

00:02:42.475 --> 00:02:47.000
When searching for MySQL vulnerabilities,
we have to change our approach a bit.

00:02:47.637 --> 00:02:50.978
This time we are not looking for
an exact version number

00:02:50.978 --> 00:02:53.166
that might be vulnerable to an exploit

00:02:53.166 --> 00:02:58.300
since MariaDB and MySQL use
different version numbers.

00:02:58.755 --> 00:03:02.400
Instead, we are trying to see
if we can identify a pattern

00:03:02.400 --> 00:03:08.333
in publicly disclosed exploits that may
indicate a type of attack we could use.

00:03:08.970 --> 00:03:14.800
We notice that the words “UDF”
and “User Defined” show up often.

00:03:15.406 --> 00:03:19.400
Let’s take a look at one of the
more recent UDF exploits.

00:03:24.437 --> 00:03:31.466
A User Defined Function (UDF) is similar
to a custom plugin for MySQL.

00:03:32.346 --> 00:03:37.500
It allows database administrators to
create custom repeatable functions

00:03:37.500 --> 00:03:40.666
to accomplish specific objectives.

00:03:41.334 --> 00:03:45.700
Conveniently for us, UDFs
are written in C or C++

00:03:45.700 --> 00:03:51.966
and can run almost any code we
want, including system commands.

00:03:52.755 --> 00:03:57.766
Researchers have discovered how
to use standard MySQL (and MariaDB)

00:03:57.766 --> 00:04:02.600
functionality to create plugins
that can be used to exploit systems.

00:04:03.237 --> 00:04:09.733
This specific exploit reveals how UDFs can
be used to escalate privileges on a host.

00:04:10.067 --> 00:04:15.600
However, we should be able to use the
same principle to get an initial shell.

00:04:16.176 --> 00:04:19.345
Some modifications will be
required but before we start

00:04:19.345 --> 00:04:22.666
changing anything,
let’s examine the code.

00:04:28.584 --> 00:04:34.633
The first thing we notice is a shellcode
variable defined on lines 40-45.

00:04:39.215 --> 00:04:44.133
The SQL query at line 71 obtains
the plugin directory.

00:04:44.831 --> 00:04:48.033
This is the non-standard
variable we found on Zora.

00:04:50.612 --> 00:04:56.100
Next, on line 92, the code dumps
the shellcode binary content

00:04:56.100 --> 00:04:59.666
into a file within the plugin directory.

00:05:00.941 --> 00:05:08.333
Line 101 creates a function named sys_exec
leveraging the uploaded binary file.

00:05:08.940 --> 00:05:15.500
Finally, the script checks if the function
was successfully created on line 104,

00:05:15.500 --> 00:05:21.200
and if this is the case, the
function is executed on line 113.

00:05:23.020 --> 00:05:26.966
According to the MySQL
CREATE FUNCTION syntax

00:05:26.966 --> 00:05:30.066
the binary content of
the shellcode variable

00:05:30.066 --> 00:05:33.366
is supposed to be a shared library

00:05:33.366 --> 00:05:38.400
that implements and exports the functions
we want to create within the database.

00:05:41.464 --> 00:05:45.833
Essentially, the entire script is
only running five commands.

00:05:47.714 --> 00:05:50.666
Since we already have an
interactive MariaDB shell,

00:05:50.666 --> 00:05:56.600
we could theoretically run these commands
directly in the MariaDB shell against Zora

00:05:58.056 --> 00:06:01.378
However, we want to make
sure we understand

00:06:01.378 --> 00:06:04.733
what we are about to
execute before proceeding.
