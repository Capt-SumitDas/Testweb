WEBVTT

00:00:01.600 --> 00:00:04.033
Changing the Overflow Buffer

00:00:05.200 --> 00:00:08.233
Let’s try to understand
our misalignment issue.

00:00:15.966 --> 00:00:17.966
Looking at where the first part
of our large

00:00:17.966 --> 00:00:20.966
padding buffer of “A”
characters is created,

00:00:20.966 --> 00:00:24.533
we notice that it starts
with a call to malloc

00:00:24.533 --> 00:00:27.033
with the size 780.

00:00:27.466 --> 00:00:30.133
This number should sound familiar.

00:00:30.133 --> 00:00:33.800
From our research during the
Windows Buffer Overflow module,

00:00:33.800 --> 00:00:38.300
we determined that 780 is
the offset in bytes

00:00:38.300 --> 00:00:41.700
required to overwrite the
return address on the stack

00:00:41.966 --> 00:00:45.066
and take control of the EIP register.

00:00:45.656 --> 00:00:51.433
The malloc function only allocates a block
of memory based on the requested size.

00:00:51.893 --> 00:00:54.566
This buffer needs to be
properly initialized,

00:00:54.566 --> 00:00:57.666
which is done using the memset function

00:00:57.666 --> 00:01:00.433
right after the call to malloc:

00:01:01.198 --> 00:01:06.766
Using memset will fill out the memory
allocation with a particular character,

00:01:06.766 --> 00:01:09.966
which in our case is 0x41,

00:01:09.966 --> 00:01:14.233
the hex representation of
the “A” character in ASCII.

00:01:14.881 --> 00:01:18.033
The next line of code in
the exploit is interesting.

00:01:18.551 --> 00:01:20.166
There’s a call to memset,

00:01:20.166 --> 00:01:24.400
which sets the last byte in the
allocation to a NULL byte.

00:01:25.138 --> 00:01:27.500
This may seem confusing at first,

00:01:27.500 --> 00:01:30.200
however, continuing to read the code,

00:01:30.200 --> 00:01:34.333
we arrive at the lines where
the final buffer is created.

00:01:39.531 --> 00:01:42.133
The code starts by allocating
a memory block

00:01:42.133 --> 00:01:45.500
for the buffer character array
using malloc

00:01:46.822 --> 00:01:49.733
and filling the array with NULL bytes.

00:01:50.887 --> 00:01:54.666
Next, the code fills the
buffer character array

00:01:55.807 --> 00:01:59.166
by copying the content
of the other variables

00:02:00.359 --> 00:02:05.666
through various string manipulation
functions such as strcpy

00:02:07.209 --> 00:02:08.333
and strcat

00:02:11.126 --> 00:02:14.266
Having the final buffer
constructed as a string

00:02:14.266 --> 00:02:17.433
 is a very important piece of information.

00:02:18.062 --> 00:02:22.300
The C programming language makes
use of null-terminated strings,

00:02:22.933 --> 00:02:26.533
meaning that functions
such as strcpy and strcat

00:02:26.533 --> 00:02:30.233
determine the end and the size of a string

00:02:30.233 --> 00:02:34.100
by searching for the first occurrence of a NULL byte

00:02:34.100 --> 00:02:36.533
in the target character array.

00:02:37.142 --> 00:02:41.766
Since the allocation size of our
initial padding buffer is 780,

00:02:41.766 --> 00:02:45.433
by setting the last byte to 0x00,

00:02:45.433 --> 00:02:49.333
we end up with a string
of “A” ASCII characters

00:02:49.333 --> 00:02:53.500
that is 779 bytes in length.

00:02:54.133 --> 00:02:58.833
This explains the misaligned
overwrite of the EIP register.

00:03:02.166 --> 00:03:06.166
We can quickly fix this by increasing
the requested memory size

00:03:06.166 --> 00:03:11.900
defined by the initial_buffer_size
variable by 1.

00:03:24.163 --> 00:03:27.600
As a final test,
we will again compile the code

00:03:29.376 --> 00:03:31.733
Our netcat listener is still waiting

00:03:31.733 --> 00:03:34.466
so we will proceed to run the exploit:

00:03:36.683 --> 00:03:39.833
And finally switch to our netcat listener:

00:03:40.581 --> 00:03:41.466
Excellent!

00:03:41.700 --> 00:03:42.966
We have a shell.

00:03:43.874 --> 00:03:46.966
In addition,
this exploit no longer requires access

00:03:46.966 --> 00:03:50.333
to a Windows-based
attack platform in the field

00:03:50.333 --> 00:03:52.900
as we can run it from Kali Linux.
