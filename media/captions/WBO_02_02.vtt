WEBVTT

00:00:01.266 --> 00:00:03.200
Controlling EIP

00:00:04.166 --> 00:00:08.133
Gaining control of the EIP register is a
crucial step

00:00:08.133 --> 00:00:11.133
when exploiting memory
corruption vulnerabilities.

00:00:11.366 --> 00:00:15.300
The EIP register is similar to 
reins on a horse; 

00:00:15.300 --> 00:00:19.600
we can use it to control the direction 
or flow of the application.

00:00:20.133 --> 00:00:24.333
However, at this point we only know that
some unknown section

00:00:24.333 --> 00:00:27.733
of our buffer of A’s overwrote EIP.

00:00:29.033 --> 00:00:33.833
Before we can load a valid destination
address into the instruction pointer 

00:00:33.833 --> 00:00:36.200
and control the execution flow, 

00:00:36.200 --> 00:00:41.233
we need to know exactly which part
of our buffer is landing in EIP.

00:00:43.266 --> 00:00:45.733
There are two common ways to
do this.

00:00:45.966 --> 00:00:50.000
First, we could attempt binary
tree analysis.



00:00:55.566 --> 00:01:01.233
Instead of 800 A’s, we send 400 A’s
and 400 B’s.

00:01:01.233 --> 00:01:05.900
If EIP is overwritten by B’s, we know the
four bytes reside

00:01:05.900 --> 00:01:08.433
in the second half of the buffer.

00:01:14.433 --> 00:01:22.266
We then change the 400 B’s to 200 B’s
and 200 C’s, and send the buffer again.

00:01:22.666 --> 00:01:27.733
If EIP is overwritten by C’s, we know that
the four bytes reside



00:01:27.733 --> 00:01:31.166
in the 600–800 byte range.

00:01:31.500 --> 00:01:33.733
We continue splitting the specific buffer 

00:01:33.733 --> 00:01:38.033
until we reach the exact four bytes
that overwrite EIP.

00:01:38.466 --> 00:01:42.566
Mathematically, this should happen
in seven iterations.

00:01:56.600 --> 00:02:01.533
However, there is a faster way to identify
the location of these four bytes.

00:02:01.866 --> 00:02:04.566
We could use a sufficiently long string

00:02:04.566 --> 00:02:10.500
that consists of non-repeating 4-byte
chunks as our fuzzing input.

00:02:11.600 --> 00:02:15.900
Then, when the EIP is overwritten with
4 bytes from our string, 

00:02:15.900 --> 00:02:20.500
we can use their unique sequence to
pinpoint exactly where 

00:02:20.500 --> 00:02:23.733
in the entire input buffer they
are located.

00:02:24.000 --> 00:02:26.666
While this may be slightly hard to
understand at first, 

00:02:26.666 --> 00:02:29.800
it becomes more clear when we apply
the technique.

00:02:34.200 --> 00:02:40.266
We’ll use Metasploit’s pattern_create Ruby
script to help us with this approach.

00:02:40.466 --> 00:02:47.966
The script can be run from any location in
Kali by running msf-pattern_create.

00:02:50.833 --> 00:02:53.233
To create the string for our proof
of concept, 

00:02:53.233 --> 00:02:59.133
we’ll pass the -l parameter, which
defines the length of our required string.

00:03:02.600 --> 00:03:06.133
The next step is to update our
Python script, 

00:03:06.133 --> 00:03:12.300
replacing the existing buffer of 800
A’s with this new unique string.

00:03:21.066 --> 00:03:24.066
Our updated proof of concept
will now send

00:03:24.066 --> 00:03:28.966
the unique 800-character string
instead of A’s.

00:03:35.133 --> 00:03:37.266
Let’s run this new script.

00:03:42.433 --> 00:03:46.900
This time, we notice that EIP
contains a new string.

00:03:47.866 --> 00:03:54.500
The EIP register has been overwritten with
42 30 61 42,

00:03:55.800 --> 00:04:04.100
the hexadecimal representation of the four
characters “B0aB”.

00:04:06.533 --> 00:04:12.033
Knowing this, we can use the companion to
pattern_create, named pattern_offset,

00:04:12.033 --> 00:04:16.700
to determine the offset of these specific
four bytes in our string.

00:04:19.800 --> 00:04:24.700
Let’s restart sync breeze and re-attach
our debugger before we try it out.

00:04:45.166 --> 00:04:49.900
In Kali, we can run the pattern_offset
script from any location

00:04:49.900 --> 00:04:54.066
with msf-pattern_offset.

00:04:54.866 --> 00:04:58.266
To find the offset where the EIP overwrite
happens,

00:04:58.266 --> 00:05:02.933
we can use -l to specify the length of our
original string,

00:05:03.733 --> 00:05:08.666
and -q to specify the bytes we found in
EIP.

00:05:11.700 --> 00:05:18.066
The msf-pattern_offset script reports that
these four bytes are located at offset 780

00:05:18.066 --> 00:05:20.333
of the 800-byte pattern.

00:05:22.366 --> 00:05:26.366
Let’s translate this to a new modified
buffer string,

00:05:26.366 --> 00:05:29.300
and see if we can get four B’s,

00:05:29.300 --> 00:05:33.233
to land precisely in the EIP register.

00:05:36.800 --> 00:05:42.000
This proof of concept creates a buffer
with 780 A’s

00:05:42.000 --> 00:05:45.600
to reach the offset found by
pattern_offset.

00:05:46.700 --> 00:05:51.733
It then uses 4 B’s to overwrite the EIP
register,

00:05:52.866 --> 00:05:59.766
followed by 16 C’s to stick to our
original 800-byte buffer length.

00:06:00.766 --> 00:06:06.466
Let’s run this latest proof of concept and
confirm our control of EIP.

00:06:15.833 --> 00:06:20.866
This time, the web server crashes, the
resulting buffer is perfectly structured,

00:06:20.866 --> 00:06:24.466
and EIP now contains our four B’s.

00:06:27.200 --> 00:06:30.933
We now have complete control over EIP

00:06:30.933 --> 00:06:36.266
and we should be able to effectively
control the execution flow of SyncBreeze!

00:06:36.900 --> 00:06:41.033
However, we’ll need to replace our hex 42
placeholder

00:06:41.033 --> 00:06:45.233
and redirect the application flow to a
valid address

00:06:45.233 --> 00:06:47.900
that points to code we want to execute.
