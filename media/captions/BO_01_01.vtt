WEBVTT

00:00:01.379 --> 00:00:02.746
Program Memory

00:00:03.734 --> 00:00:06.101
When a binary application is executed,

00:00:06.113 --> 00:00:09.479
it allocates memory in
a very specific way

00:00:09.498 --> 00:00:12.898
within the memory boundaries
used by modern computers.

00:00:14.898 --> 00:00:18.798
This figure shows how process
memory is allocated in Windows

00:00:18.798 --> 00:00:21.164
between the lowest memory address

00:00:21.682 --> 00:00:24.849
and the highest memory
address used by applications.

00:00:25.701 --> 00:00:28.667
Although there are several memory
areas outlined in this figure,

00:00:28.667 --> 00:00:32.534
for our purposes, we’ll
solely focus on the stack.

00:00:35.346 --> 00:00:36.413
The Stack

00:00:37.613 --> 00:00:41.913
When a thread is running, it executes code
from within the Program Image

00:00:41.931 --> 00:00:45.664
or from various DLLs loaded
by the application.

00:00:46.982 --> 00:00:51.416
The thread requires a short-term
data area for functions,

00:00:51.416 --> 00:00:54.982
local variables, and program
control information.

00:00:55.501 --> 00:00:58.667
This data area is known as the stack.

00:00:59.179 --> 00:01:02.679
To facilitate independent
execution of multiple threads,

00:01:02.679 --> 00:01:06.946
each thread in a running
application has its own stack.

00:01:07.464 --> 00:01:13.131
Stack memory is “viewed” by the CPU
as a Last-In First-Out structure.

00:01:13.664 --> 00:01:16.564
This essentially means that
while accessing the stack,

00:01:16.564 --> 00:01:21.598
items “pushed” on the top of the
stack are “popped” off first.

00:01:22.598 --> 00:01:27.564
The x86 architecture implements
dedicated PUSH and POP

00:01:27.564 --> 00:01:32.731
assembly instructions in order to add
data or remove it from the stack.

00:01:37.098 --> 00:01:39.664
Function Return Mechanics

00:01:40.798 --> 00:01:43.664
When code within a thread
calls a function,

00:01:43.664 --> 00:01:48.798
it must know which address to
return to once the function completes.

00:01:50.931 --> 00:01:55.364
This “return address”, along
with the function’s parameters

00:01:55.364 --> 00:01:59.164
and local variables, is
stored on the stack.

00:01:59.798 --> 00:02:03.431
This collection of data is associated
with one function call

00:02:03.431 --> 00:02:09.064
and is stored in a section of the stack
memory known as a stack frame.

00:02:09.764 --> 00:02:13.731
When a function ends, the return
address is taken from the stack

00:02:13.731 --> 00:02:18.164
and used to restore the execution flow
back to the main program

00:02:18.164 --> 00:02:19.998
or the calling function.

00:02:20.531 --> 00:02:22.898
While this describes the
process at a high level,

00:02:22.898 --> 00:02:28.398
we must understand more about how this is
actually accomplished at the CPU level.

00:02:30.031 --> 00:02:34.164
This requires a discussion
about CPU registers.
