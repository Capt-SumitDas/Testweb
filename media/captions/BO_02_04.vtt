WEBVTT

00:00:01.838 --> 00:00:03.438
Overflowing the Buffer

00:00:07.148 --> 00:00:12.348
In the previous example, we only
wrote 12 bytes out of the available 64 

00:00:12.348 --> 00:00:16.814
so the program ran and
exited cleanly as expected.

00:00:17.399 --> 00:00:18.233
However,

00:00:18.271 --> 00:00:23.504
the offset between the buffer address
and the main function return address

00:00:24.002 --> 00:00:29.119
is 76 bytes, which is equal
to 4C in hex.

00:00:29.119 --> 00:00:35.466
So if we supply 80 “A”’s as an argument,
they should all be copied onto the stack

00:00:35.466 --> 00:00:38.981
and write past the bounds
of the  assigned buffer

00:00:38.981 --> 00:00:41.981
into the target return address.

00:00:43.886 --> 00:00:47.819
To do this, we can reopen the
application from the File menu

00:00:47.819 --> 00:00:50.986
and enter 80 A’s for the Argument.

00:00:55.443 --> 00:00:59.076
Now let’s find the string
copy function again.

00:01:08.276 --> 00:01:12.943
Since immunity debugger saves breakpoints
accross different debugging sessions

00:01:12.943 --> 00:01:16.743
our breakpoint is still set on
the call to string copy.

00:01:17.286 --> 00:01:21.753
We’ll press F9 to run the program
until the breakpoint is hit.

00:01:23.814 --> 00:01:29.681
We have hit our breakpoint so we’ll step
into the string copy function with F7.

00:01:30.943 --> 00:01:36.609
Then we’ll execute up to the
return instruction with control-F9.

00:01:45.258 --> 00:01:47.891
If we continue the execution with F7

00:01:47.891 --> 00:01:51.586
and proceed to the RETN instruction
in the main function,

00:01:51.586 --> 00:01:56.119
the overwritten return address,
part of our string of A’s,

00:01:56.119 --> 00:01:58.686
will be popped into EIP.

00:02:02.781 --> 00:02:11.048
At this point, the CPU tries to read
the next instruction from 41414141,

00:02:11.048 --> 00:02:14.914
the hex representation
of our string of A’s.

00:02:16.363 --> 00:02:20.429
Since this is not a valid address
in the process memory space,

00:02:20.429 --> 00:02:25.619
the CPU triggers an access violation,
which crashes the application.

00:02:26.414 --> 00:02:32.614
Once again, it’s important to keep in mind
that the EIP register is used by the CPU

00:02:32.614 --> 00:02:36.381
to direct code execution at
the assembly level.

00:02:37.943 --> 00:02:42.043
Therefore, obtaining reliable
control of EIP

00:02:42.043 --> 00:02:47.776
would allow us to execute any assembly
code we want, even shellcode

00:02:47.776 --> 00:02:52.643
to obtain a reverse shell in the
context of the vulnerable application.

00:02:56.494 --> 00:02:58.061
In this module, we presented the

00:02:58.066 --> 00:03:01.791
basic principles behind a
buffer overflow attack.

00:03:02.581 --> 00:03:06.548
Specifically, we demonstrated
how to control EIP.

00:03:09.248 --> 00:03:13.948
In later modules we’ll demonstrate how
to exploit a similar vulnerability.
