WEBVTT

00:00:00.666 --> 00:00:03.666
Boolean Logical Operations


00:00:03.933 --> 00:00:07.466
Boolean logical operators, like AND and OR

00:00:07.466 --> 00:00:12.100
are somewhat mysterious because Bash uses
them in a variety of ways.

00:00:12.266 --> 00:00:15.366
One common use is in command lists, 

00:00:15.366 --> 00:00:19.533
which are chains of commands whose flow 
is controlled by operators.

00:00:19.766 --> 00:00:23.400
The pipe symbol is a commonly-used 
operator in a command list

00:00:23.400 --> 00:00:28.066
and passes the output of one command to 
the input of another.

00:00:28.700 --> 00:00:33.566
Similarly, boolean logical operators 
execute commands based on whether

00:00:33.566 --> 00:00:39.466
a previous command succeeded, meaning it 
returned True or 0, or failed, 

00:00:39.466 --> 00:00:42.166
by returning False or non-zero.

00:00:45.066 --> 00:00:47.500
Let’s take a look at the AND operator 
first, 

00:00:47.500 --> 00:00:51.866
which executes a command only if the 
previous command succeeds, 

00:00:51.866 --> 00:00:54.466
or returns True or 0.

00:00:54.966 --> 00:00:58.666
In this example, we first assign the user 
name we are searching for

00:00:58.666 --> 00:01:00.633
to the user2 variable.

00:01:02.066 --> 00:01:07.466
Next, we use grep to check if a certain 
user is listed in the /etc/passwd file…


00:01:07.766 --> 00:01:13.133
…and if it is, grep returns True and the 
echo command is executed.


00:01:15.133 --> 00:01:18.700
Now let’s try it with a condition that 
returns false.


00:01:23.633 --> 00:01:28.500
When we try searching for a user that we 
know does not exist in /etc/passwd,

00:01:28.600 --> 00:01:32.433
grep returns False and our echo command 
is not executed.

00:01:34.433 --> 00:01:38.700
When used in a command list, the OR 
operator is the opposite of AND.


00:01:38.866 --> 00:01:43.233
It executes the next command only if the 
previous command failed, 

00:01:43.233 --> 00:01:46.466
meaning it returned False or non-zero.

00:01:49.200 --> 00:01:52.900
In this example, we took our previous 
command a step further and added 

00:01:52.900 --> 00:01:56.866
the OR operator followed by a second echo command.

00:01:58.000 --> 00:02:02.000
Now, when grep does not find a matching 
line and returns False, 

00:02:02.000 --> 00:02:07.866
the echo command after the OR operator is 
executed instead of the one after AND.

00:02:08.233 --> 00:02:12.266
These operators can also be used in a 
test to compare variables

00:02:12.266 --> 00:02:14.833
or the results of other tests.


00:02:16.033 --> 00:02:20.133
When used this way, AND combines two 
simple conditions, 

00:02:20.133 --> 00:02:26.266
and if they are both true, the combined 
result is success, returning True or 0.

00:02:26.900 --> 00:02:28.433
Consider this example:


00:02:30.566 --> 00:02:34.766
In this example, we use AND to test 
multiple conditions…


00:02:34.766 --> 00:02:38.400
…and since both variable comparisons are 
true, 

00:02:38.400 --> 00:02:43.333
the whole if line succeeds, so the then 
branch will be executed.

00:02:43.800 --> 00:02:48.233
We’ll make this script executable and run 
it to see if our logic is sound.


00:02:53.133 --> 00:02:54.433
It appears to have worked.


00:02:57.066 --> 00:03:00.100
Great, let’s move on to the OR operator.


00:03:01.333 --> 00:03:02.666
When used in a test, 

00:03:02.666 --> 00:03:06.633
the OR operator is used to test one or 
more conditions

00:03:06.633 --> 00:03:10.700
but only one of them has to be true to 
count as success.

00:03:10.700 --> 00:03:12.233
Let’s take a look at an example:


00:03:14.166 --> 00:03:18.333
In this example, we use OR to test 
multiple conditions.


00:03:18.333 --> 00:03:20.000
Let’s give this a try.


00:03:25.166 --> 00:03:28.166
Since one of the variable comparisons was true, 

00:03:28.166 --> 00:03:30.600
the whole if line succeeded,

00:03:30.600 --> 00:03:33.100
so the then branch executed.
