WEBVTT

00:00:01.700 --> 00:00:04.133
Finding a Return Address

00:00:05.166 --> 00:00:09.833
We can still store our shellcode at the
address pointed to by ESP,

00:00:09.833 --> 00:00:13.666
but we need a consistent way to get that
code executed.

00:00:14.466 --> 00:00:18.866
One solution is to leverage a JMP ESP
instruction,

00:00:18.866 --> 00:00:25.133
which as the name suggests, “jumps” to the
address pointed to by ESP

00:00:25.133 --> 00:00:26.533
when it executes.

00:00:27.733 --> 00:00:33.566
If we can find a reliable, static address
that contains this instruction,

00:00:33.566 --> 00:00:38.700
we can redirect EIP to this address and at
the time of the crash,

00:00:38.700 --> 00:00:42.333
the JMP ESP instruction will be executed.

00:00:42.966 --> 00:00:49.600
This “indirect jump” will lead the
execution flow into our shellcode.

00:00:50.066 --> 00:00:55.133
Many support libraries in Windows
contain this commonly-used instruction

00:00:55.500 --> 00:00:59.733
but we need to find a reference that meets
certain criteria.

00:01:00.100 --> 00:01:04.933
First, the addresses used in the library
must be static,

00:01:04.933 --> 00:01:08.700
which eliminates libraries compiled with
ASLR support.

00:01:08.700 --> 00:01:15.066
Secondly, the address of the instruction
must not contain any of the bad characters

00:01:15.066 --> 00:01:18.433
that would break the exploit, since the
address itself

00:01:18.433 --> 00:01:20.833
will be part of our input buffer.

00:01:21.333 --> 00:01:25.733
We can use the Immunity Debugger script,
mona.py,

00:01:25.733 --> 00:01:30.633
developed by the Corelan team, to begin
our return address search.

00:01:31.133 --> 00:01:36.533
First we will request information about
all DLLs (or modules)

00:01:36.533 --> 00:01:43.366
loaded by SyncBreeze into the process
 memory space with mona modules.

00:01:57.533 --> 00:02:02.266
The columns in this output include the
current memory location

00:02:02.266 --> 00:02:05.233
in other words, the base and top
addresses,

00:02:05.900 --> 00:02:08.066
the size of the module,

00:02:09.166 --> 00:02:11.133
several flags,

00:02:12.966 --> 00:02:16.366
and the module version, name, and path.

00:02:23.733 --> 00:02:28.366
From the flags in this output, we can see
that the Sync Breeze executable has

00:02:28.366 --> 00:02:33.733
SafeSEH, ASLR, and NXCompat disabled.

00:02:35.966 --> 00:02:40.000
In other words, the executable has not
been compiled

00:02:40.000 --> 00:02:45.066
with any memory protection schemes, and
will always reliably load

00:02:45.066 --> 00:02:49.466
at the same address, making it ideal for
our purposes.

00:02:50.166 --> 00:02:56.466
However, it always loads at the base
address 00 40 00 00,

00:02:56.666 --> 00:03:01.800
meaning all instruction addresses will
contain null characters,

00:03:02.066 --> 00:03:04.400
which are not suitable for our buffer.

00:03:05.433 --> 00:03:11.433
Searching through the output, we find that
LIBSSP.DLL also suits our needs

00:03:11.433 --> 00:03:15.233
and the address range doesn’t seem to
contain bad characters.

00:03:17.600 --> 00:03:20.233
This is perfect for our needs.

00:03:20.366 --> 00:03:24.666
Now we need to find the address of a
naturally-occurring

00:03:24.666 --> 00:03:28.200
JMP ESP instruction within this module.

00:03:29.633 --> 00:03:33.900
We could use native commands within the
Immunity Debugger to search for our

00:03:33.900 --> 00:03:39.633
JMP ESP, but the search would have to be
performed on multiple data areas

00:03:39.633 --> 00:03:41.433
inside the DLL.

00:03:41.933 --> 00:03:47.900
Instead, we can use mona.py to perform an
exhaustive search for the binary

00:03:47.900 --> 00:03:53.766
or hexadecimal representation (or opcode)
of the assembly instruction.

00:03:57.666 --> 00:04:03.533
To find the opcode equivalent of JMP ESP,
we can use the Metasploit NASM Shell

00:04:03.533 --> 00:04:08.066
ruby script, msf-nasm_shell.

00:04:10.033 --> 00:04:11.700
To make use of this tool,

00:04:11.700 --> 00:04:15.200
we simply need to enter the instruction
we’re interested in.

00:04:17.500 --> 00:04:24.200
The NASM shell tells us that the opcode we
need to search for is FF E4.

00:04:31.633 --> 00:04:36.900
We can search for JMP ESP using the hex
representation of the opcode

00:04:36.900 --> 00:04:42.566
in all sections of LIBSSP.DLL with
mona find.

00:04:43.800 --> 00:04:47.500
We will specify the content of the search
with -s

00:04:47.500 --> 00:04:50.933
and the escaped value of the opcode’s hex
string.

00:04:51.466 --> 00:04:57.200
We also provide the name of the required
module with the -m option.

00:05:00.900 --> 00:05:07.333
In this example, the output reveals one
address containing a JMP ESP instruction,

00:05:08.333 --> 00:05:13.533
and fortunately, the address does not
contain any of our bad characters.

00:05:13.966 --> 00:05:17.100
To view the contents of this address in
the disassembler window,

00:05:17.333 --> 00:05:19.266
while execution is paused,

00:05:19.466 --> 00:05:23.566
we will click the “Go to address in
Disassembler” button

00:05:23.866 --> 00:05:25.266
and enter the address.

00:05:29.266 --> 00:05:35.000
From here we can see that it does indeed
translate to a JMP ESP instruction.

00:05:35.666 --> 00:05:40.033
If we redirect EIP to this address at the time of the crash,

00:05:40.033 --> 00:05:43.300
the JMP ESP instruction will be executed,

00:05:43.300 --> 00:05:47.533
which will lead the execution flow into
our shellcode.

00:05:48.100 --> 00:05:50.400
Before inspecting our next proof of
concept,

00:05:50.400 --> 00:05:53.200
we’ll restart and re-attach our debugger.

00:06:15.000 --> 00:06:18.366
We’ll also set a breakpoint on our return
address

00:06:18.366 --> 00:06:22.433
in order to follow the execution of the
JMP ESP instruction.

00:06:27.200 --> 00:06:30.466
We can set this breakpoint by pressing F2.

00:06:31.533 --> 00:06:36.200
Now we’ll let the application run with F9
and return to Kali.

00:06:42.700 --> 00:06:46.466
We have updated our eip variable to
reflect the address of the

00:06:46.466 --> 00:06:48.200
JMP ESP instruction.

00:06:49.333 --> 00:06:52.300
Note that the address is in reverse order.

00:06:52.566 --> 00:06:55.633
This is because of endian byte order.

00:06:55.866 --> 00:07:01.333
The operating system can store addresses
and data in memory in different formats.

00:07:01.533 --> 00:07:05.600
Generally speaking, the format used to
store addresses in memory

00:07:05.600 --> 00:07:09.533
depends on the architecture the operating
system is running on.

00:07:09.900 --> 00:07:13.600
Little endian is the most widely-used
format,

00:07:13.600 --> 00:07:19.566
while big endian was historically used by
the Sparc and PowerPC architectures.

00:07:19.900 --> 00:07:24.200
In little endian format the low-order byte
of the number

00:07:24.200 --> 00:07:27.300
is stored in memory at the lowest address,

00:07:27.300 --> 00:07:30.433
and the high-order byte at the highest
address.

00:07:30.433 --> 00:07:35.900
Therefore, we have to store the return
address in reverse order in our buffer

00:07:35.900 --> 00:07:39.833
for the CPU to interpret it correctly in
memory.

00:07:40.066 --> 00:07:43.633
Now let’s try out this latest proof of
concept.

00:07:52.300 --> 00:07:56.300
Our debugger shows that we did in fact
reach our JMP ESP

00:07:56.300 --> 00:07:59.133
and hit the breakpoint we previously set.

00:07:59.633 --> 00:08:03.900
Pressing F7 in the debugger will
single-step into our shellcode

00:08:03.900 --> 00:08:07.966
placeholder, which is currently just a
bunch of D’s.

00:08:07.966 --> 00:08:12.400
Great! Now we just need to generate
working shellcode

00:08:12.400 --> 00:08:14.733
and our exploit will be complete.

00:08:15.100 --> 00:08:16.866
Let’s reset our environment.

00:08:41.166 --> 00:08:45.000
We’ll set our breakpoint on the JMP ESP
instruction again,

00:08:50.366 --> 00:08:52.566
and let it run.
