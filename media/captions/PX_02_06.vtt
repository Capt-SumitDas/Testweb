WEBVTT

00:00:01.943 --> 00:00:06.833
Windows Kernel Vulnerabilities:
USBPcap Case Study

00:00:07.742 --> 00:00:11.298
Once again, this section of the
module will not be reproducible

00:00:11.298 --> 00:00:13.675
on the dedicated student client.

00:00:14.243 --> 00:00:17.966
In this section, we will demonstrate
a privilege escalation

00:00:17.966 --> 00:00:21.500
that relies on a kernel
driver vulnerability.

00:00:27.123 --> 00:00:30.100
When attempting to exploit
system-level software,

00:00:30.100 --> 00:00:35.600
such as drivers or the kernel itself,
we must pay careful attention

00:00:35.600 --> 00:00:38.400
to several pieces of important information

00:00:38.400 --> 00:00:42.833
including the operating system,
version, and architecture.

00:00:43.515 --> 00:00:46.600
Failure to accurately identify
these factors can trigger

00:00:46.600 --> 00:00:49.600
a Blue Screen of Death
while running the exploit.

00:00:54.570 --> 00:00:57.100
As a first step, we will
determine the version

00:00:57.100 --> 00:00:59.666
and architecture of
the operating system.

00:01:07.676 --> 00:01:14.600
Our target is running Windows
7 SP1 on an x86 processor.

00:01:16.162 --> 00:01:19.533
At this point, we could search
for a native kernel vulnerability

00:01:19.533 --> 00:01:25.533
for Windows 7 SP1 x86 and
use it to elevate our privileges.

00:01:25.845 --> 00:01:30.666
However, since third-party driver
exploits are more common,

00:01:30.666 --> 00:01:35.300
we should always attempt to
investigate this attack surface first.

00:01:35.896 --> 00:01:39.517
To do this, we’ll first enumerate
the drivers that are installed on

00:01:39.517 --> 00:01:46.333
the system using the driverquery command,
specifying /v for verbose output:

00:01:58.007 --> 00:02:02.133
There are mostly Microsoft-installed
drivers listed

00:02:02.133 --> 00:02:06.966
and a few third party
drivers such as USBPcap.

00:02:08.756 --> 00:02:11.300
Even though the driver
is marked as stopped,

00:02:11.300 --> 00:02:14.000
we may still be able
to interact with it,

00:02:14.000 --> 00:02:17.233
because it is loaded in
the kernel memory space.

00:02:23.794 --> 00:02:27.633
Let’s search for USBPcap
in the Exploit Database:

00:02:30.331 --> 00:02:34.500
Searchspoilt lists one
exploit for USBPcap.

00:02:34.840 --> 00:02:36.600
Let’s have a closer look at it.

00:02:39.525 --> 00:02:44.966
This particular exploit targets our
operating system version and architecture.

00:02:45.364 --> 00:02:49.500
However, it depends on a specific
version of the driver,

00:02:49.500 --> 00:03:00.200
namely USBPcap version 1.1.0.0, which
is installed along with Wireshark 2.2.5.

00:03:01.506 --> 00:03:04.029
Let’s take a look at our target
system to see if that

00:03:04.029 --> 00:03:06.666
particular version of
the driver is installed.

00:03:17.403 --> 00:03:21.666
To begin, we will list the contents
of the Program Files directory,

00:03:21.666 --> 00:03:25.566
to see if it contains a
USBPcap directory:

00:03:30.366 --> 00:03:35.733
It appears there is a USBPcap
directory in Program Files.

00:03:36.926 --> 00:03:41.233
Let’s inspect the contents of
the USBPcap.inf file

00:03:41.233 --> 00:03:46.233
in the USBPcap directory to learn
more about the driver version:

00:03:56.202 --> 00:04:00.500
Based on the version information, our
driver should be vulnerable.

00:04:13.622 --> 00:04:17.700
Before we try to exploit it, we first
have to compile the exploit.

00:04:26.022 --> 00:04:31.133
Compiling C/C++ Code on Windows

00:04:31.900 --> 00:04:36.166
The vast majority of exploits
targeting kernel-level vulnerabilities

00:04:36.166 --> 00:04:41.933
are written in a low-level programming
language such as C or C++

00:04:41.933 --> 00:04:44.233
and needs to be compiled first.

00:04:44.574 --> 00:04:50.000
Ideally, we would compile the code on the
platform version it is intended to run on.

00:04:54.658 --> 00:04:59.600
We will compile it on our
Windows client using Mingw-w64,

00:04:59.600 --> 00:05:03.733
which provides a GCC
compiler on Windows.

00:05:07.709 --> 00:05:12.533
Since our Windows client has
Mingw-w64 pre-installed,

00:05:14.890 --> 00:05:20.333
we can run the mingw-w64.bat script

00:05:20.333 --> 00:05:26.033
that sets-up the PATH environment
variable for the gcc executable.

00:05:28.476 --> 00:05:33.233
Once the script is finished,
we can execute gcc.exe

00:05:33.233 --> 00:05:36.433
to confirm that everything
is working properly:

00:05:39.273 --> 00:05:42.100
Good. The compiler
seems to be working.

00:05:44.031 --> 00:05:49.166
Now, let’s transfer the exploit code to
our Windows client and compile it.

00:06:04.816 --> 00:06:08.100
Since the author did not include
any compilation instructions,

00:06:08.100 --> 00:06:13.000
we will try to run gcc without
any arguments other than -o.

00:06:14.846 --> 00:06:17.000
Despite two warning messages,

00:06:21.033 --> 00:06:23.866
the exploit compiled successfully.

00:06:24.832 --> 00:06:27.457
Now that we have compiled our
exploit we can transfer it

00:06:27.457 --> 00:06:30.300
to our target machine
and attempt to run it.

00:06:44.473 --> 00:06:47.866
In order to determine if our privilege
escalation is successful,

00:06:47.866 --> 00:06:53.533
we will use the whoami command
before and after running our exploit:

00:07:04.639 --> 00:07:10.333
Excellect! We have successfully
elevated our privileges from n00b

00:07:10.333 --> 00:07:13.066
to nt authority\system,

00:07:13.066 --> 00:07:17.400
which is the Windows account
with the highest privilege level.
