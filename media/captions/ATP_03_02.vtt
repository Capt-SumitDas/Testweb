WEBVTT

00:00:01.201 --> 00:00:03.866
Attempting to Exploit the Database

00:00:04.953 --> 00:00:08.666
While the individual commands
give us no reason for concern,

00:00:08.666 --> 00:00:12.466
we have no idea what
the shellcode is doing.

00:00:12.924 --> 00:00:14.900
Instead of using the built in shellcode,

00:00:14.900 --> 00:00:18.866
we’ll replace it with something
that we’re in control of.

00:00:24.329 --> 00:00:27.966
After a bit of research, we find
a promising GitHub project.

00:00:31.999 --> 00:00:35.866
Let’s download the code,
review it, and compile it.

00:00:48.936 --> 00:00:52.552
This file is a fairly standard
UDF library

00:00:52.552 --> 00:00:57.100
that allows for execution of system
commands through the system function.

00:00:57.900 --> 00:01:02.676
Moreover, according to the code, the
function exported by the shared library

00:01:02.676 --> 00:01:08.200
after compilation is named sys_exec
as in the previous exploit.

00:01:08.886 --> 00:01:12.390
We’ll need to create a MySQL
function with the same name

00:01:12.390 --> 00:01:15.833
in order to execute system
commands from the database.

00:01:20.923 --> 00:01:24.966
Now that we have reviewed the code,
we will compile the shared library.

00:01:25.624 --> 00:01:27.414
As a prerequisite for compilation,

00:01:27.414 --> 00:01:32.366
we need to install the MySQL
database development files.

00:01:37.371 --> 00:01:40.147
Now that we have the dependencies
installed, we need to

00:01:40.147 --> 00:01:44.433
remove the old object file
before generating the new one.

00:01:50.410 --> 00:01:53.866
Looking at the Makefile, we’ll
need to make some minor adjustments

00:01:53.866 --> 00:01:57.366
to ensure we can compile
the source file correctly.

00:01:58.167 --> 00:02:03.000
Specifically, we need to adjust the
include directory path for the gcc command

00:02:03.000 --> 00:02:08.633
since our Kali system is running
MariaDB and not MySQL.

00:02:20.759 --> 00:02:25.133
The -I flags include the
header file directories.

00:02:26.105 --> 00:02:29.200
The -shared flag tells gcc

00:02:29.200 --> 00:02:34.600
that this is a shared library and
to generate a shared object file.

00:02:35.314 --> 00:02:38.866
Finally, -o sets our output file name.

00:02:44.329 --> 00:02:48.866
Now let’s compile the code by
running the make command.

00:02:50.868 --> 00:02:53.900
Recalling the SQL commands
from the UDF exploit,

00:02:53.900 --> 00:03:00.033
we will transfer the shared library to
the target database server as a hex dump.

00:03:01.606 --> 00:03:04.166
We will use xxd for this.

00:03:05.167 --> 00:03:12.300
The -p flag outputs a plain hexdump, which
makes it easier for further manipulation.

00:03:13.329 --> 00:03:16.733
We'll use tr to delete the
new line character,

00:03:17.534 --> 00:03:21.366
and then dump the contents
of the output to a file.

00:03:23.282 --> 00:03:27.933
We will use xclip to copy the contents
of the hex file to the clipboard.

00:03:30.507 --> 00:03:33.000
This will serve as our shellcode.

00:03:33.543 --> 00:03:37.266
Now we have everything we
need to attempt to exploit Zora.

00:03:38.610 --> 00:03:40.600
We just need to put it together.

00:03:43.059 --> 00:03:46.518
Before we begin running the malicious
SQL commands, we will create

00:03:46.518 --> 00:03:51.466
a variable in MariaDB for the shellcode
that we have copied to our clipboard.

00:03:52.553 --> 00:03:56.400
Note the addition of “0x” to the
beginning of the shellcode

00:03:56.400 --> 00:03:59.700
and the lack of single or double quotes.

00:04:00.071 --> 00:04:04.600
This ensures that MariaDB will
read the text as binary.

00:04:10.176 --> 00:04:12.500
Next, per the exploit instructions,

00:04:12.500 --> 00:04:16.033
we will confirm the location
of the plugin directory.

00:04:20.523 --> 00:04:25.133
Now, we need to output the
shellcode to a file on Zora.

00:04:25.819 --> 00:04:29.400
The original exploit generates a
random filename for this,

00:04:29.400 --> 00:04:31.133
but we can name it whatever we want.

00:04:32.363 --> 00:04:38.400
This command tells MariaDB to treat the
contents of the shell variable as binary,

00:04:39.486 --> 00:04:43.400
and to output it to a file
in the plugin directory.

00:04:45.830 --> 00:04:50.300
Unfortunately, this is where
we encounter our first problem.

00:04:51.129 --> 00:04:53.966
According to the error
message, the wp user

00:04:53.966 --> 00:04:57.966
does not have permissions
to create files.

00:05:02.084 --> 00:05:03.766
Why We Failed

00:05:04.910 --> 00:05:10.600
While the user does have permissions to
run SELECT, INSERT, UPDATE, and DELETE,

00:05:10.600 --> 00:05:17.433
the wp user is missing the FILE permissions
which allows us to run dumpfile.

00:05:18.777 --> 00:05:23.400
To run dumpfile, we need a user account
with a higher level of permissions,

00:05:23.400 --> 00:05:26.266
such as the root user.

00:05:26.266 --> 00:05:28.833
Without this, we’re stuck.

00:05:29.519 --> 00:05:33.500
We can’t further exploit Zora
with this approach.

00:05:34.300 --> 00:05:38.233
The first logical option that comes
to mind is to go back to Ajla

00:05:38.233 --> 00:05:43.433
and see if we can find root
(or similar) MariaDB credentials.
